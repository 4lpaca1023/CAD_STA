#@ # 
#@ # Running lc_shell Version U-2022.12-SP6 for linux64 -- Aug 08, 2023
#@ # Date:   Mon Dec  1 22:56:46 2025
#@ # Run by: B11215045@cadlab206
#@ 

source /usr/cad/synopsys/lc/2022.12-sp6/admin/setup//.synopsys_lc.setup
#@ # -- Starting source /usr/cad/synopsys/lc/2022.12-sp6/admin/setup//.synopsys_lc.setup

#@ #
#@ #
#@ #		".synopsys_lc.setup" Initialization File for
#@ #
#@ #		    Lc_Shell and Library_compiler
#@ #
#@ #	The variables in this file define the behavior of many parts
#@ #	of the Synopsys Synthesis Tools.  Upon installation, they should 
#@ #	be reviewed and modified to fit your site's needs.  Each engineer
#@ #	can have a .synopsys file in his/her home directory or current
#@ #	directory to override variable settings in this file.  
#@ #
#@ 
#@ # System variables
#@ # system default value for sh_continue_on_error is "false"
#@ set sh_continue_on_error         "true"
#@ # system default value for sh_source_uses_search_path is "false"
#@ set sh_source_uses_search_path   "true"
#@ 
#@ # Enable customer support banner on fatal
#@ if { $sh_arch == "linux"    || $sh_arch == "amd64"    || $sh_arch == "linux64" || \
#@      $sh_arch == "sparcOS5" || $sh_arch == "sparc64"  || \
#@      $sh_arch == "x86sol32" || $sh_arch == "x86sol64" || \
#@      $sh_arch == "rs6000"   || $sh_arch == "aix64" } {
#@    setenv SYNOPSYS_TRACE ""
#@ }
#@ 
#@ #
#@ # Load the procedures which make up part of the user interface.
#@ #
#@ source $synopsys_root/auxx/syn/.lc_procs.tcl
#@ # -- Starting source /usr/cad/synopsys/lc/2022.12-sp6/auxx/syn/.lc_procs.tcl

#@ ##############################################################################
#@ #
#@ #
#@ # FILE:         auxx/syn/.lc_procs.tcl
#@ #
#@ # ABSTRACT:     These procedures are part of the lc_shell
#@ #               user interface.
#@ #               They are loaded by .synopsys_lc.setup.
#@ #
#@ ##############################################################################
#@ #
#@ #
#@ 
#@ ##############################################################################
#@ #
#@ #
#@ #  PROCEDURE:  add_model
#@ #
#@ #  ABSTRACT:  dummy call
#@ #
#@ ##############################################################################
#@ #
#@ 
#@ proc add_model { args } {
#@   return [uplevel #0 $cmd]
#@ }
#@ 
#@ ##############################################################################
#@ #
#@ #  PROCEDURE:   remove_design
#@ #
#@ #  ABSTRACT:    map remove_design to remove_lib
#@ #
#@ #  HISTORY :    2014/05/09, Synopsys, initial
#@ #
#@ ##############################################################################
#@ 
#@ proc remove_design { args } {
#@   parse_proc_arguments -args $args ra
#@ 
#@   if {[info exists ra(-library)]} {
#@     set cmd [format {remove_lib %s} $ra(-library)]
#@   } elseif {[info exists ra(-all)]} {
#@     set cmd {remove_lib -all}
#@   } else {
#@     set cmd [format {remove_lib [list %s]} $args]
#@   }
#@ 
#@   return [uplevel #0 $cmd]
#@ }
#@ 
#@ define_proc_attributes remove_design -hide_body \
#@     -info " alias of remove_lib " \
#@     -define_args {\
#@       {file_names "" file_names list {optional hidden}}\
#@     }
#@ # -- End source /usr/cad/synopsys/lc/2022.12-sp6/auxx/syn/.lc_procs.tcl

#@ source $synopsys_root/auxx/lc/.lc_scripts.tcl
#@ # -- Starting source /usr/cad/synopsys/lc/2022.12-sp6/auxx/lc/.lc_scripts.tcl

#@ ##############################################################################
#@ #
#@ #
#@ # FILE:         lc_scripts.tcl
#@ #
#@ # ABSTRACT:     These procedures are part of the lc_shell
#@ #               user interface.
#@ #               They are loaded by .synopsys_lc.setup.
#@ #
#@ ##############################################################################
#@ 
#@ ##############################################################################
#@ # Proc: read in the csv file to list of list
#@ # Author: Synopsys
#@ # Date: 2015/11/01
#@ # -channel: the input csv file
#@ # -header: == 1: use first line as index; header == 0: use row number as index
#@ # -symbol: delimiter, default is ","
#@ ##############################################################################
#@ proc read_csv { channel { header 1 } { symbol , }} {
#@ 	set quote 0	
#@ 	set data [ split [ read $channel nonewline ] "\n" ]
#@ 	foreach line $data {
#@ 		set quote [ expr { $quote + [ regexp -all \" $line ]}]
#@ 		if { [ expr { $quote % 2 }] == "0" } {
#@ 			set quote 0
#@ 			append row_temp $line
#@ 			set row_temp [ split $row_temp , ]	
#@ 			foreach section $row_temp {
#@ 				set quote [ expr { $quote + [ regexp -all \" $section ]}]
#@ 				if { [ expr { $quote % 2 }] == "0" } {
#@ 					append cell_temp $section
#@ 					set cell_temp [ regsub {^\s*(.*\S)\s*$} $cell_temp {\1} ]
#@ 					set cell_temp [ regsub {^\s*$} $cell_temp {\1} ]
#@ 					set cell_temp [ regsub {"(.*)"} $cell_temp {\1} ]
#@ 					lappend cell $cell_temp
#@ 					unset cell_temp
#@ 					set quote 0
#@ 				} else {
#@ 					append cell_temp $section$symbol
#@ 				}
#@ 			}
#@ 			lappend final [ regsub -all {""} $cell \" ]
#@ 			unset cell
#@ 			unset row_temp
#@ 		} else {
#@ 			append row_temp $line\n
#@ 		}
#@ 	}
#@ 	# return list of list
#@ 	return $final
#@ }
#@ 
#@ # This proc is hidden
#@ define_proc_attributes read_csv -hidden
#@ 
#@ ##############################################################################
#@ # Proc: sort the db_filename
#@ # Author: Synopsys
#@ # Date: 2015/11/01
#@ # Return array: key is db name, value is a list of colomn number
#@ ##############################################################################
#@ proc sort_array_by_db_filename { final id } {
#@ 	set row [ llength $final ]
#@ 
#@ 	for { set i 1 } { $i < $row } { incr i } {
#@ 		set db_name [lindex [lindex $final $i] $id]
#@     set db_ids [array names db_map $db_name]
#@     if { [string length $db_ids] > 0} {
#@       set db_map($db_name) [concat $db_map($db_name) $i]
#@     } else {
#@       set db_map($db_name) $i
#@     }
#@   }
#@ 
#@   return [ array get db_map ]
#@ }
#@ 
#@ # This proc is hidden
#@ define_proc_attributes sort_array_by_db_filename -hidden
#@ 
#@ ##############################################################################
#@ # Proc: get nldm delay point index/value
#@ # Author: Synopsys
#@ # Date: 2015/11/01
#@ # Args: -matching_point: 1: fit; others: bucket;
#@ # Return: for fit mode, return 1 grid point
#@ #   for bucket mode, return a list of grid points
#@ #
#@ # Support NLDM NLPM query
#@ #
#@ # For different dimension lookup table
#@ #         fit                     bucket
#@ #   2-D:  1 (idx1,idx2,val)       4 * 3 (idx1,idx2,val)
#@ #   1-D:  1 (idx1,val)            2 * 2 (idx1,val)
#@ #   0-D:  1 (val)                 1 (val)
#@ #
#@ # The return array always contain 3 items (fit mode) or 12 items (bucket mode)
#@ # The unused ones are left empty for 1-D/0-D lookup table
#@ # If find any error, return array contains same number itmes with empty value
#@ ##############################################################################
#@ proc get_nldm_delay_point { line header idx {matching_point 1} } {
#@ 
#@   set column [llength $header]
#@ 	for { set j 0 } { $j < $column } { incr j } {
#@ 		set rec([ lindex $header $j ],$idx) [ lindex $line $j ]
#@   }
#@ 
#@   # initial return array
#@   if { $matching_point ==1 } {
#@     set tb(idx1,$idx) ""
#@     set tb(idx2,$idx) ""
#@     set tb(value,$idx) ""
#@   } else {
#@     set tb(idx1_a,$idx) ""
#@     set tb(idx2_a,$idx) ""
#@     set tb(value_a,$idx) ""
#@     set tb(idx1_b,$idx) ""
#@     set tb(idx2_b,$idx) ""
#@     set tb(value_b,$idx) ""
#@     set tb(idx1_c,$idx) ""
#@     set tb(idx2_c,$idx) ""
#@     set tb(value_c,$idx) ""
#@     set tb(idx1_d,$idx) ""
#@     set tb(idx2_d,$idx) ""
#@     set tb(value_d,$idx) ""
#@   }
#@ 
#@   # check library
#@   if { [string length [array names rec library,$idx]] ==0 ||
#@     [string length $rec(library,$idx)] ==0} {
#@     echo "line [expr $idx+1]: Error! Must specify field 'library' for query."
#@     return [ array get tb ]
#@   }
#@   # check cell 
#@   if { [string length [array names rec cell,$idx]] ==0 ||
#@     [string length $rec(cell,$idx)] ==0} {
#@     echo "line [expr $idx+1]: Error! Must specify field 'cell' for query."
#@     return [ array get tb ]
#@   }
#@ 
#@   # get the cell, save the collection into global array for fast access next time.
#@   global lc_cells
#@   set lib_cell_name [array names lc_cells $rec(library,$idx)/$rec(cell,$idx)]
#@   if { [string length $lib_cell_name] > 0} {
#@     set pcell $lc_cells($lib_cell_name)
#@   } else {
#@     set pcell [get_lib_cells $rec(library,$idx)/$rec(cell,$idx)]
#@     if { [sizeof_collection $pcell] == 1 } {
#@       set lc_cells($rec(library,$idx)/$rec(cell,$idx)) $pcell
#@     } else {
#@       echo "line [expr $idx+1]: Error! Can't find this cell group."
#@       return [array get tb ]
#@     }
#@   }
#@ 
#@   # check group
#@   if { [string length [array names rec group,$idx]] ==0 ||
#@     [string length $rec(group,$idx)] ==0} {
#@     echo "line [expr $idx+1]: Error! Must specify field 'group' for query."
#@     return [ array get tb ]
#@   }
#@ 
#@   # get value NOT from lookup table
#@   if { [string equal $rec(group,$idx) leakage_power] } {
#@     # leakage power
#@  
#@     # set filter
#@     if { [string length [array names rec when_cond,$idx]] >0 &&
#@       [string length $rec(when_cond,$idx)] >0 } {
#@       set ft \(when==\"$rec(when_cond,$idx)\"\)
#@     }
#@     if { [string length [array names rec related_pg_pin,$idx]] >0 &&
#@       [string length $rec(related_pg_pin,$idx)] >0 } {
#@       if {[info exists ft]} {
#@         set ft $ft&&\(related_pg_pin==$rec(related_pg_pin,$idx)\)
#@       } else {
#@         set ft \(related_pg_pin==$rec(related_pg_pin,$idx)\)
#@       } 
#@     }
#@ 
#@     # set options: of_object, class_type, filter
#@     lappend opts -of_objects $pcell -class_type leakage_power
#@     if {[info exists ft]} {
#@       lappend opts -filter $ft
#@     }
#@ 
#@     # get leakage power 
#@     set arc [eval get_lib_objects $opts]
#@     
#@     if {[sizeof_collection $arc] == 0} {
#@       echo "line [expr $idx+1]: Error! Can't find this timing/power group."
#@       return [array get tb ]
#@     } elseif {[sizeof_collection $arc] > 1} {
#@     # using the first one !!!
#@       echo "line [expr $idx+1]: Warning! Find multiple timing/power groups, use the first one!"
#@       set arc [index_collection $arc 0]
#@     }
#@ 
#@     set value [format %g [get_lib_attribute $arc value]]
#@ 
#@     if { $matching_point ==1 } {
#@       if {[info exists value]} {
#@         set tb(value,$idx) $value
#@       }
#@     } else {
#@       if {[info exists value]} {
#@         set tb(value_a,$idx) $value
#@       }
#@     }
#@ 
#@     return [ array get tb ]
#@   }
#@ 
#@   # get value from lookup table
#@   if { [string equal $rec(group,$idx) cell_rise] ||
#@     [string equal $rec(group,$idx) cell_fall] ||
#@     [string equal $rec(group,$idx) rise_constraint] ||
#@     [string equal $rec(group,$idx) fall_constraint] ||
#@     [string equal $rec(group,$idx) rise_propagation] ||
#@     [string equal $rec(group,$idx) fall_propagation] ||
#@     [string equal $rec(group,$idx) rise_transition] ||
#@     [string equal $rec(group,$idx) fall_transition] ||
#@     [string equal $rec(group,$idx) ocv_sigma_cell_rise] ||
#@     [string equal $rec(group,$idx) ocv_sigma_cell_fall] ||
#@     [string equal $rec(group,$idx) ocv_sigma_rise_constraint] ||
#@     [string equal $rec(group,$idx) ocv_sigma_fall_constraint] ||
#@     [string equal $rec(group,$idx) ocv_sigma_rise_transition] ||
#@     [string equal $rec(group,$idx) ocv_sigma_fall_transition] } {
#@     # NLDM timing
#@ 
#@     # set filter
#@     if { [string length [array names rec timing_type,$idx]] >0 &&
#@       [string length $rec(timing_type,$idx)] >0 } {
#@       set ft \(timing_type==$rec(timing_type,$idx)\)
#@     }
#@     if { [string length [array names rec timing_sense,$idx]] >0 &&
#@       [string length $rec(timing_sense,$idx)] >0 } {
#@       if {[info exists ft]} {
#@         set ft $ft&&\(timing_sense==$rec(timing_sense,$idx)\)
#@       } else {
#@         set ft \(timing_sense==$rec(timing_sense,$idx)\)
#@       } 
#@     }
#@     if { [string length [array names rec when_cond,$idx]] >0 &&
#@       [string length $rec(when_cond,$idx)] >0 } {
#@       if {[info exists ft]} {
#@         set ft $ft&&\(when==\"$rec(when_cond,$idx)\"\)
#@       } else {
#@         set ft \(when==\"$rec(when_cond,$idx)\"\)
#@       }
#@     }
#@ 
#@     # set options: of_object, from pin, to pin, filter
#@     lappend opts -of_objects $pcell
#@     if { [string length [array names rec pin,$idx]] >0 &&
#@       [string length $rec(pin,$idx)] >0 } {
#@       lappend opts -to $rec(pin,$idx)
#@     }
#@     if { [string length [array names rec related_pin,$idx]] >0 &&
#@       [string length $rec(related_pin,$idx)] >0 } {
#@       lappend opts -from $rec(related_pin,$idx)
#@     }
#@     if {[info exists ft]} {
#@       lappend opts -filter $ft
#@     }
#@   
#@     # get timing arc
#@     set arc [eval get_lib_timing_arcs $opts]
#@ 
#@   } elseif { [string equal $rec(group,$idx) rise_power] ||
#@     [string equal $rec(group,$idx) fall_power] } {
#@     # NLPM internal power
#@ 
#@     # set filter
#@     if { [string length [array names rec when_cond,$idx]] >0 &&
#@       [string length $rec(when_cond,$idx)] >0 } {
#@       set ft \(when==\"$rec(when_cond,$idx)\"\)
#@     }
#@     if { [string length [array names rec related_pg_pin,$idx]] >0 &&
#@       [string length $rec(related_pg_pin,$idx)] >0 } {
#@       if {[info exists ft]} {
#@         set ft $ft&&\(related_pg_pin==$rec(related_pg_pin,$idx)\)
#@       } else {
#@         set ft \(related_pg_pin==$rec(related_pg_pin,$idx)\)
#@       } 
#@     }
#@     if { [string length [array names rec related_pin,$idx]] >0 &&
#@       [string length $rec(related_pin,$idx)] >0 } {
#@       if {[info exists ft]} {
#@         set ft $ft&&\(related_pin==$rec(related_pin,$idx)\)
#@       } else {
#@         set ft \(related_pin==$rec(related_pin,$idx)\)
#@       } 
#@     }
#@ 
#@     # get pin
#@     if { [string length [array names rec pin,$idx]] >0 &&
#@       [string length $rec(pin,$idx)] >0 } {
#@       set pin [get_lib_objects -of_objects $pcell -class_type pin -filter name==$rec(pin,$idx)]
#@       if {[sizeof_collection $pin] != 1} {
#@         echo "line [expr $idx+1]: Error! Can't find this pin group."
#@         return [array get tb ]
#@       }
#@ 
#@       # set options: of_object, -class_type, filter
#@       lappend opts -of_objects $pin -class_type internal_power
#@       if {[info exists ft]} {
#@         lappend opts -filter $ft
#@       }
#@       
#@       # get internal power 
#@       set arc [eval get_lib_objects $opts]
#@     }
#@   }
#@ 
#@   if {[sizeof_collection $arc] == 0} {
#@     echo "line [expr $idx+1]: Error! Can't find this timing/power group."
#@     return [array get tb ]
#@   } elseif {[sizeof_collection $arc] > 1} {
#@     # using the first one !!!
#@     echo "line [expr $idx+1]: Warning! Find multiple timing/power groups, use the first one!"
#@     set arc [index_collection $arc 0]
#@   }
#@ 
#@   # get the lookup table
#@   set lt [get_lookup_table -of_object $arc $rec(group,$idx)]
#@ 
#@   if {[sizeof_collection $lt] == 0} {
#@     echo "line [expr $idx+1]: Error! Can't find this lookup table."
#@     return [array get tb ]
#@   } elseif {[sizeof_collection $lt] > 1} {
#@     # using the first one !!!
#@     echo "line [expr $idx+1]: Warning! Find multiple lookup table, use the first one!"
#@     set lt [index_collection $lt 0]
#@   }
#@ 
#@   # won't consider index pairing for now
#@   # input_slew == input_net_transition/input_transition_time
#@   # output_load == total_output_net_capacitance
#@   set index1 input_net_transition
#@   set index2 total_output_net_capacitance
#@ 
#@   set ids [lookup_table variables $lt]
#@   
#@   if { [llength $ids] == 1} {
#@     set index1 [lindex $ids 0]
#@   } elseif { [llength $ids] == 2} {
#@     set index1 [lindex $ids 0]
#@     set index2 [lindex $ids 1]
#@   }
#@     
#@   # constraint template could have issue here
#@   # constraint variable related_pin_transition/constrained_pin_transition
#@   # doesn't follow the input csv table index name input_slew/output_load
#@   # then we don't know how to pair them
#@   if { $index1=="total_output_net_capacitance" } {
#@     set tmp_index $index1
#@     set index1 $index2
#@     set index2 $tmp_index
#@   }
#@ 
#@   if { [string length [array names rec input_slew,$idx]] >0 &&
#@     [string length $rec(input_slew,$idx)] >0 } {
#@     lappend pointl $index1 $rec(input_slew,$idx)
#@   }
#@   if { [string length [array names rec output_load,$idx]] >0 &&
#@     [string length $rec(output_load,$idx)] >0 } {
#@     lappend pointl $index2 $rec(output_load,$idx)
#@   }
#@ 
#@   # lookup_table fit/bucket â€¦
#@   if { $matching_point ==1 } {
#@     if {[info exists pointl]} {
#@       redirect -variable msg {echo [set m_list [lookup_table fit $lt -index $pointl]]}
#@     } else {
#@       redirect -variable msg {echo [set m_list [lookup_table fit $lt]]}
#@     }
#@     if {[info exists m_list]} {
#@       if {[llength $m_list] == 3} {
#@         set tb(idx1,$idx) [format %g [lindex $m_list 0] ]
#@         set tb(idx2,$idx) [format %g [lindex $m_list 1] ]
#@         set tb(value,$idx) [format %g [lindex $m_list 2] ]
#@       } elseif {[llength $m_list] == 2} {
#@         set tb(idx1,$idx) [format %g [lindex $m_list 0] ]
#@         set tb(value,$idx) [format %g [lindex $m_list 1] ]
#@       } elseif {[llength $m_list] == 1} {
#@         set tb(value,$idx) [format %g [lindex $m_list 0] ]
#@       }
#@     }
#@   } else {
#@     if {[info exists pointl]} {
#@       redirect -variable msg {echo [set m_list [lookup_table bucket $lt -index $pointl]]}
#@     } else {
#@       redirect -variable msg {echo [set m_list [lookup_table bucket $lt]]}
#@     }
#@     if {[info exists m_list]} {
#@       if {[llength $m_list] == 4} {
#@         set tb(idx1_a,$idx) [format %g [lindex [lindex $m_list 0] 0] ]
#@         set tb(idx2_a,$idx) [format %g [lindex [lindex $m_list 0] 1] ]
#@         set tb(value_a,$idx)  [format %g [lindex [lindex $m_list 0] 2] ]
#@         set tb(idx1_b,$idx) [format %g [lindex [lindex $m_list 1] 0] ]
#@         set tb(idx2_b,$idx) [format %g [lindex [lindex $m_list 1] 1] ]
#@         set tb(value_b,$idx)  [format %g [lindex [lindex $m_list 1] 2] ]
#@         set tb(idx1_c,$idx) [format %g [lindex [lindex $m_list 2] 0] ]
#@         set tb(idx2_c,$idx) [format %g [lindex [lindex $m_list 2] 1] ]
#@         set tb(value_c,$idx)  [format %g [lindex [lindex $m_list 2] 2] ]
#@         set tb(idx1_d,$idx) [format %g [lindex [lindex $m_list 3] 0] ]
#@         set tb(idx2_d,$idx) [format %g [lindex [lindex $m_list 3] 1] ]
#@         set tb(value_d,$idx)  [format %g [lindex [lindex $m_list 3] 2] ]
#@       } elseif {[llength $m_list] == 2} {
#@         set tb(idx1_a,$idx) [format %g [lindex [lindex $m_list 0] 0] ]
#@         set tb(value_a,$idx)  [format %g [lindex [lindex $m_list 0] 1] ]
#@         set tb(idx1_b,$idx) [format %g [lindex [lindex $m_list 1] 0] ]
#@         set tb(value_b,$idx)  [format %g [lindex [lindex $m_list 1] 1] ]
#@       } elseif {[llength $m_list] == 1} {
#@         set tb(value_a,$idx) [format %g [lindex $m_list 0] ]
#@       }
#@     }
#@   }
#@   if {[string match {[a-zA-Z]*} $msg]} {
#@     echo Line [expr $idx+1]: Error! [string trim $msg \n]
#@   }
#@ 
#@   return [ array get tb ]
#@ }
#@ 
#@ # This proc is hidden
#@ define_proc_attributes get_nldm_delay_point -hidden
#@ 
#@ ##############################################################################
#@ # Proc: get_lib_grid_points
#@ # Author: Synopsys
#@ # Date: 2015/11/01
#@ # -matching_point: 1 fit; 2 bucket
#@ # -input_csv_file: the input csv file contains the querry condition
#@ # -output_csv_file: the input csv file contains the querry condition and query result
#@ #
#@ # Modified: Synopsys 2015/12/10
#@ #   change proc name from "check_qualified_data_point" to "get_lib_lookup_data"
#@ # Modified: Synopsys 2016/01/05
#@ #   change proc name from "get_lib_lookup_data" to "get_lib_grid_points"
#@ ##############################################################################
#@ proc get_lib_grid_points {args} {
#@ 
#@   # get the args
#@   parse_proc_arguments -args $args ra
#@   set input_csv_file $ra(input_csv_file)
#@   set output_csv_file $ra(output_csv_file)
#@ 
#@   if { [string length [array names ra matching_point]] ==0 } {
#@     set matching_point 1
#@   } else {
#@     set matching_point $ra(matching_point)
#@   }
#@ 
#@   # get the input csv data, put in 2-D table (list of list)
#@   set in [open $input_csv_file r]
#@   set table [ read_csv $in ]
#@   close $in
#@ 	
#@   # get row/column/header
#@   set row [ llength $table ]
#@   set header [ lindex $table 0 ]
#@   set column [ llength $header ]
#@ 
#@   # check each header index name is correct
#@   set all_header {db_filename instance library cell pin group related_pin timing_type timing_sense when_cond related_pg_pin input_slew output_load}
#@   foreach item $header {
#@     if {[lsearch -exact $all_header $item] <0 } {
#@       echo "Error: Can't use '$item' as index."
#@       echo "The allowed index names are 'db_filename instance library cell pin group related_pin timing_type timing_sense when_cond related_pg_pin input_slew output_load'."
#@       return;
#@     }
#@   }
#@   
#@   # db_id is the colomn for "db_filename"
#@   set db_id [lsearch -exact $header db_filename]
#@   if { $db_id <0 } {
#@     echo "Error: User must specify 'db_filename' index in the input_csv_file."
#@     return
#@   }
#@   set lib_id [lsearch -exact $header library]
#@   if { $lib_id <0 } {
#@     echo "Error: User must specify 'library' index in the input_csv_file."
#@     return
#@   }
#@   
#@   # db_map is the mapping from db_filename to "row number" list
#@   array set db_map [sort_array_by_db_filename $table $db_id]
#@   set db_names [array names db_map]
#@   global lc_cells
#@   
#@   # set process meter
#@   incr row -1
#@   set count 1
#@   if { $row > 10000 } {
#@     set pct_instance [expr $row/100]
#@   } else {
#@     set pct_instance 100
#@   }
#@   
#@   # check each db at a time for saving memory
#@   foreach db $db_names {
#@     redirect -variable msg {echo [read_db $db]}
#@     set idx_list $db_map($db)
#@     array set lc_cells {0 0}
#@     foreach idx $idx_list {
#@ 
#@       # echo process meter
#@       if { $count % $pct_instance == 0 } {
#@         echo "Processing Cell Instance $count : out of $row"
#@         #echo [eval date]
#@       }
#@ 
#@       # get the querry data
#@       set line [lindex $table $idx]
#@       array set result [get_nldm_delay_point $line $header $idx $matching_point]
#@       
#@       # save the querry result
#@       if { $matching_point ==1 } {
#@         lappend line $result(idx1,$idx)
#@         lappend line $result(idx2,$idx)
#@         lappend line $result(value,$idx)
#@       } else {
#@         lappend line $result(idx1_a,$idx)
#@         lappend line $result(idx2_a,$idx)
#@         lappend line $result(value_a,$idx)
#@         lappend line $result(idx1_b,$idx)
#@         lappend line $result(idx2_b,$idx)
#@         lappend line $result(value_b,$idx)
#@         lappend line $result(idx1_c,$idx)
#@         lappend line $result(idx2_c,$idx)
#@         lappend line $result(value_c,$idx)
#@         lappend line $result(idx1_d,$idx)
#@         lappend line $result(idx2_d,$idx)
#@         lappend line $result(value_d,$idx)
#@       }
#@       set table [lreplace $table $idx $idx $line]
#@       
#@       incr count
#@     }
#@     unset lc_cells
#@ 		set lib_name [lindex [lindex $table $idx] $lib_id]
#@     redirect -variable msg {echo [remove_lib $db:$lib_name]}
#@ 
#@   }
#@ 
#@   # write to output csv file
#@   set out [open $output_csv_file w+]
#@ 
#@   if { $matching_point ==1 } {
#@     lappend header idx1 idx2 value
#@   } else {
#@     lappend header idx1_a idx2_a value_a idx1_b idx2_b value_b idx1_c idx2_c value_c idx1_d idx2_d value_d
#@   }
#@   set table [lreplace $table 0 0 $header]
#@   set row [ llength $table ]
#@   set column [ llength $header ]
#@ 
#@   set symbol ,
#@   for { set i 0 } { $i < $row } { incr i } {		
#@     puts -nonewline $out [lindex [lindex $table $i] 0]
#@ 	  for { set j 1 } { $j < $column } { incr j } {
#@       puts -nonewline $out $symbol
#@       puts -nonewline $out [lindex [lindex $table $i] $j]
#@ 		}
#@     puts $out ""
#@ 	}
#@   close $out
#@ 
#@ }
#@ 
#@ define_proc_attributes get_lib_grid_points \
#@     -info " Get the qualified grid points based on query parameter" \
#@     -define_args {
#@       {input_csv_file "The input file name contains query parameter" input_csv_file string required}
#@       {output_csv_file "The output file name for query result" output_csv_file string required}
#@       {matching_point "Query method: '1' for 1-closest grid point (default), '4' for 4 bucket grid points" matching_point one_of_string {optional value_help {values {1 4}}}}
#@ }
#@ 
#@ ##############################################################################
#@ # proc: write_records_in_csv
#@ # Output the data extracted from SQL database to $out_file csv file
#@ # file_id: fild id from csv filenam $out_file
#@ # arr: collection from SQL query commands
#@ # num_col: number of columns in $out_file
#@ ##############################################################################
#@ proc write_records_in_csv {file_id arr num_col} {
#@   global out_file
#@   set sz [expr [llength $arr]/$num_col]
#@   for {set i 0} {$i < $sz} {incr i} {
#@     set val ""
#@     for {set j 0} {$j < $num_col} {incr j} {
#@ 	set val1 [lindex $arr [expr $i*$num_col+$j]]   
#@ 	if {$j == 0} {
#@ 	    set val $val1
#@ 	} else {  
#@ 	    set val [concat $val,$val1]  
#@ 	} 
#@ 	#puts stdout j=$j
#@     }
#@     puts $file_id $val
#@     #puts stdout i=$i
#@   }
#@   #puts stdout "$sz records written to $out_file"
#@ }
#@ 
#@ define_proc_attributes write_records_in_csv -hidden
#@ 
#@ # -- End source /usr/cad/synopsys/lc/2022.12-sp6/auxx/lc/.lc_scripts.tcl

#@ source $synopsys_root/auxx/lc/analyze_trend.tcl
#@ # -- Starting source /usr/cad/synopsys/lc/2022.12-sp6/auxx/lc/analyze_trend.tcl

#@ ##############################################################################
#@ # Proc: analyze_trend   Author: Synopsys   Date: 2015/12/09
#@ #   analyze the input float array monotonicity trend
#@ #   return a char like "-, /, \, V, ^, N, u, M, W, X"
#@ # float_list: input float list, must be at least 2 members
#@ # -relative_tolerance: relative tolerance, default is 0.01
#@ # -absolute_tolerance: absolute tolerance, default is 0.000001
#@ ##############################################################################
#@ proc analyze_trend { args } {
#@ 
#@   # get the args
#@   parse_proc_arguments -args $args ra
#@   set float_list $ra(float_list)
#@ 
#@   if { [string length [array names ra -relative_tolerance]] ==0 } {
#@     set rel_tol 0.01
#@   } else {
#@     set rel_tol $ra(-relative_tolerance)
#@   }
#@   if { [string length [array names ra -absolute_tolerance]] ==0 } {
#@     set abs_tol 0.000001
#@   } else {
#@     set abs_tol $ra(-absolute_tolerance)
#@   }
#@   
#@   set count [llength $float_list]
#@   if {$count <= 1} {
#@     echo "Can't analysis: list must have at least 2 members."
#@   }
#@ 
#@   set trend 0
#@   
#@   for { set i 0 } { $i < $count - 1 } { incr i } {
#@     set fa [lindex $float_list $i]
#@     set fb [lindex $float_list $i+1]
#@ 
#@     set gap [expr abs($fa-$fb)]
#@     set rel_gap [expr ($fa+$fb)*0.5*$rel_tol]
#@     
#@     if {$gap <= $abs_tol || $gap <= $rel_gap} {
#@       switch -exact -- $trend {
#@         "0" { set trend "-" }
#@         "-" { set trend "-" }
#@         "\\" { set trend "\\" }
#@         "/" { set trend "/" }
#@         "V" { set trend "V" }
#@         "^" { set trend "^" }
#@         "N" { set trend "N" }
#@         "u" { set trend "u" }
#@         "M" { set trend "M" }
#@         "W" { set trend "W" }
#@         default { set trend "X" }
#@       }
#@     } elseif {$fa > $fb} {
#@       switch -exact -- $trend {
#@         "0" { set trend "\\" }
#@         "-" { set trend "\\" }
#@         "\\" { set trend "\\" }
#@         "/" { set trend "^" }
#@         "V" { set trend "u" }
#@         "^" { set trend "^" }
#@         "u" { set trend "u" }
#@         "N" { set trend "M" }
#@         "M" { set trend "M" }
#@         "W" { set trend "X" }
#@         default { set trend "X" }
#@       }
#@     } elseif {$fa < $fb} {
#@       switch -exact -- $trend {
#@         "0" { set trend "/" }
#@         "-" { set trend "/" }
#@         "\\" { set trend "V" }
#@         "/" { set trend "/" }
#@         "V" { set trend "V" }
#@         "^" { set trend "N" }
#@         "N" { set trend "N" }
#@         "u" { set trend "W" }
#@         "M" { set trend "X" }
#@         "W" { set trend "W" }
#@         default { set trend "X" }
#@       }
#@     }
#@     if {$trend == "X"} {break}
#@   }
#@ 
#@   return $trend
#@ }
#@ 
#@ define_proc_attributes analyze_trend \
#@     -info " Analyze the trend of a float list" \
#@     -define_args {
#@       {float_list "The list contains float array for analysis" float_list list required}
#@       {-relative_tolerance "The relative tolerance for the float equal comparing, default is 0.01." relative_tolerance float optional}
#@       {-absolute_tolerance "The absolute tolerance for the float equal comparing, default is 1e-6." absolute_tolerance float optional}
#@ }
#@ 
#@ # -- End source /usr/cad/synopsys/lc/2022.12-sp6/auxx/lc/analyze_trend.tcl

#@ source $synopsys_root/auxx/lc/get_scale.tcl
#@ # -- Starting source /usr/cad/synopsys/lc/2022.12-sp6/auxx/lc/get_scale.tcl

#@ ##############################################################################
#@ # Proc: get_time_scale   Author: Synopsys   Date: 2015/12/09
#@ #   unified time unit is 1ns
#@ #   return the scale value from the unit to the unified unit. 
#@ ##############################################################################
#@ proc get_time_scale { unit } {
#@ 
#@   set val 0
#@ 
#@   scan $unit %f%s digit class
#@   
#@   switch -exact -- $class {
#@     "fs"    { set val 1e-6 }
#@     "ps"    { set val 1e-3 }
#@     "ns"    { set val 1 }
#@     "us"    { set val 1e3 }
#@     "ms"    { set val 1e6 }
#@     "s"     { set val 1e9 }
#@     "ks"    { set val 1e12 }
#@     default { echo "Error! The unit '$unit' is not a 'time' unit" }
#@   }
#@ 
#@   set val [expr $val * $digit]
#@   
#@   return $val
#@ }
#@ # This proc is hidden
#@ define_proc_attributes get_time_scale -hidden
#@ 
#@ ##############################################################################
#@ # Proc: get_voltage_scale   Author: Synopsys   Date: 2015/12/09
#@ #   unified voltage unit is 1v
#@ #   return the scale value from the unit to the unified unit. 
#@ ##############################################################################
#@ proc get_voltage_scale { unit } {
#@ 
#@   set val 0
#@ 
#@   scan $unit %f%s digit class
#@   
#@   switch -exact -- $class {
#@     "fv"    { set val 1e-15 }
#@     "pv"    { set val 1e-12 }
#@     "nv"    { set val 1e-9 }
#@     "uv"    { set val 1e-6 }
#@     "mv"    { set val 1e-3 }
#@     "v"     { set val 1 }
#@     "kv"    { set val 1e3 }
#@     default { echo "Error! The unit '$unit' is not a 'voltage' unit" }
#@   }
#@ 
#@   set val [expr $val * $digit]
#@   
#@   return $val
#@ }
#@ # This proc is hidden
#@ define_proc_attributes get_voltage_scale -hidden
#@ 
#@ ##############################################################################
#@ # Proc: get_current_scale   Author: Synopsys   Date: 2015/12/09
#@ #   unified current unit is 1a
#@ #   return the scale value from the unit to the unified unit. 
#@ ##############################################################################
#@ proc get_current_scale { unit } {
#@ 
#@   set val 0
#@ 
#@   scan $unit %f%s digit class
#@ 
#@   switch -exact -- $class {
#@     "fa"    { set val 1e-15 }
#@     "pa"    { set val 1e-12 }
#@     "na"    { set val 1e-9 }
#@     "ua"    { set val 1e-6 }
#@     "ma"    { set val 1e-3 }
#@     "a"     { set val 1 }
#@     "ka"    { set val 1e3 }
#@     default { echo "Error! The unit '$unit' is not a 'current' unit" }
#@   }
#@   
#@   set val [expr $val * $digit]
#@   
#@   return $val
#@ }
#@ # This proc is hidden
#@ define_proc_attributes get_current_scale -hidden
#@ 
#@ ##############################################################################
#@ # Proc: get_power_scale   Author: Synopsys   Date: 2015/12/09
#@ #   unified power unit is 1w
#@ #   return the scale value from the unit to the unified unit. 
#@ ##############################################################################
#@ proc get_power_scale { unit } {
#@ 
#@   set val 0
#@ 
#@   scan $unit %f%s digit class
#@ 
#@   switch -exact -- $class {
#@     "fw"    { set val 1e-15 }
#@     "pw"    { set val 1e-12 }
#@     "nw"    { set val 1e-9 }
#@     "uw"    { set val 1e-6 }
#@     "mw"    { set val 1e-3 }
#@     "w"     { set val 1 }
#@     "kw"    { set val 1e3 }
#@     default { echo "Error! The unit '$unit' is not a 'power' unit" }
#@   }
#@   
#@   set val [expr $val * $digit]
#@   
#@   return $val
#@ }
#@ # This proc is hidden
#@ define_proc_attributes get_power_scale -hidden
#@ 
#@ ##############################################################################
#@ # Proc: get_resistance_scale   Author: Synopsys   Date: 2015/12/09
#@ #   unified resistance unit is 1ohm
#@ #   return the scale value from the unit to the unified unit. 
#@ ##############################################################################
#@ proc get_resistance_scale { unit } {
#@ 
#@   set val 0
#@ 
#@   scan $unit %f%s digit class
#@ 
#@   switch -exact -- $class {
#@     "fohm"    { set val 1e-15 }
#@     "pohm"    { set val 1e-12 }
#@     "nohm"    { set val 1e-9 }
#@     "uohm"    { set val 1e-6 }
#@     "mohm"    { set val 1e-3 }
#@     "ohm"     { set val 1 }
#@     "kohm"    { set val 1e3 }
#@     default  { echo "Error! The unit '$unit' is not a 'resistance' unit" }
#@   }
#@   
#@   set val [expr $val * $digit]
#@   
#@   return $val
#@ }
#@ # This proc is hidden
#@ define_proc_attributes get_resistance_scale -hidden
#@ 
#@ ##############################################################################
#@ # Proc: get_capacitance_scale   Author: Synopsys   Date: 2015/12/09
#@ #   unified capacitance unit is 1f
#@ #   return the scale value from the unit to the unified unit. 
#@ ##############################################################################
#@ proc get_capacitance_scale { unit } {
#@ 
#@   set val 0
#@ 
#@   scan $unit %f%s digit class
#@ 
#@   switch -exact -- $class {
#@     "ff"    { set val 1e-15 }
#@     "pf"    { set val 1e-12 }
#@     "nf"    { set val 1e-9 }
#@     "uf"    { set val 1e-6 }
#@     "mf"    { set val 1e-3 }
#@     "f"     { set val 1 }
#@     "kf"    { set val 1e3 }
#@     default { echo "Error! The unit '$unit' is not a 'capacitance' unit" }
#@   }
#@   
#@   set val [expr $val * $digit]
#@   
#@   return $val
#@ }
#@ # This proc is hidden
#@ define_proc_attributes get_capacitance_scale -hidden
#@ 
#@ ##############################################################################
#@ # Proc: get_energy_scale   Author: Synopsys   Date: 2015/12/09
#@ #   unified energy unit is 1j
#@ #   return the scale value from the unit to the unified unit. 
#@ ##############################################################################
#@ proc get_energy_scale { unit } {
#@ 
#@   set val 0
#@ 
#@   scan $unit %f%s digit class
#@ 
#@   switch -exact -- $class {
#@     "fj"    { set val 1e-15 }
#@     "pj"    { set val 1e-12 }
#@     "nj"    { set val 1e-9 }
#@     "uj"    { set val 1e-6 }
#@     "mj"    { set val 1e-3 }
#@     "j"     { set val 1 }
#@     "kj"    { set val 1e3 }
#@     default { echo "Error! The unit '$unit' is not a 'energy' unit" }
#@   }
#@   
#@   set val [expr $val * $digit]
#@   
#@   return $val
#@ }
#@ # This proc is hidden
#@ define_proc_attributes get_energy_scale -hidden
#@ 
#@ ##############################################################################
#@ # Proc: get_scale   Author: Synopsys   Date: 2015/12/09
#@ #   This command will analyze the unit in the source library, and return 
#@ #   the scale value from the library unit to the target unit. 
#@ #   If any error happens, return 0.
#@ # -type: Unit type (time| voltage| current | power| capacitance | resistance| energy)
#@ # -target_unit: The target unit for sacle 
#@ #     [float][magnitude][unit]
#@ # -library: The source library.
#@ # For example: get_scale time 10.0ps $lib
#@ # Recommand unit type:
#@ #     For time: 1ps| 1ns
#@ #	    For voltage: 1mv| 1v
#@ #	    For current: 1ua| 1ma| 1a
#@ #	    For power: 1pw| 1nw| 1uw| 1mw
#@ #	    For capacitance: 1ff| 1pf
#@ #	    For resistance: 1ohm| 1kohm
#@ #	    For energy: 1fj| 1pj| 1nj| 1uj
#@ ##############################################################################
#@ proc get_scale { args } {
#@ 
#@   set val 0 
#@   
#@   # get the args
#@   parse_proc_arguments -args $args ra
#@   set type $ra(type)
#@   set target_unit $ra(target_unit)
#@   set library $ra(library)
#@   
#@   # time
#@   if { $type=="time" } {
#@     set t_unit_scale [get_time_scale $target_unit]
#@     set unit [get_lib_attribute $library time_unit]
#@     set s_unit_scale [get_time_scale $unit]
#@     if {$t_unit_scale>0 && $s_unit_scale>0} {
#@       set val [expr $s_unit_scale/$t_unit_scale]
#@     }
#@ 
#@   # voltage
#@   } elseif { $type=="voltage" } {
#@     set t_unit_scale [get_voltage_scale $target_unit]
#@     set unit [get_lib_attribute $library voltage_unit]
#@     set s_unit_scale [get_voltage_scale $unit]
#@     if {$t_unit_scale>0 && $s_unit_scale>0} {
#@       set val [expr $s_unit_scale/$t_unit_scale]
#@     }
#@ 
#@   # current
#@   } elseif { $type=="current" } {
#@     set t_unit_scale [get_current_scale $target_unit]
#@     set unit [get_lib_attribute $library current_unit]
#@     set s_unit_scale [get_current_scale $unit]
#@     if {$t_unit_scale>0 && $s_unit_scale>0} {
#@       set val [expr $s_unit_scale/$t_unit_scale]
#@     }
#@ 
#@   # power
#@   } elseif { $type=="power" } {
#@     set t_unit_scale [get_power_scale $target_unit]
#@     set unit [get_lib_attribute $library leakage_power_unit]
#@     set s_unit_scale [get_power_scale $unit]
#@     if {$t_unit_scale>0 && $s_unit_scale>0} {
#@       set val [expr $s_unit_scale/$t_unit_scale]
#@     }
#@ 
#@   # capacitance
#@   } elseif { $type=="capacitance" } {
#@     set t_unit_scale [get_capacitance_scale $target_unit]
#@     # unit is string like "xxxpf" or "xxxff" returned by get_lib_attribute
#@     set unit [get_lib_attribute $library capacitive_load_unit]
#@     set s_unit_scale [get_capacitance_scale $unit]
#@     if {$t_unit_scale>0 && $s_unit_scale>0} {
#@       set val [expr $s_unit_scale/$t_unit_scale]
#@     }
#@     
#@   # resistance
#@   } elseif { $type=="resistance" } {
#@     set t_unit_scale [get_resistance_scale $target_unit]
#@     set unit [get_lib_attribute $library pulling_resistance_unit]
#@     set s_unit_scale [get_resistance_scale $unit]
#@     if {$t_unit_scale>0 && $s_unit_scale>0} {
#@       set val [expr $s_unit_scale/$t_unit_scale]
#@     }
#@ 
#@   # energy
#@   } elseif { $type=="energy" } {
#@     set t_unit_scale [get_energy_scale $target_unit]
#@     # c_unit is string like "xxxpf" or "xxxff" returned by get_lib_attribute
#@     set c_unit [get_lib_attribute $library capacitive_load_unit]
#@     set c_unit [get_capacitance_scale $c_unit]
#@     set v_unit [get_lib_attribute $library voltage_unit]
#@     set v_unit_scale [get_voltage_scale $v_unit]
#@     set s_unit_scale [expr $c_unit * $v_unit_scale * $v_unit_scale]
#@     if {$t_unit_scale>0 && $s_unit_scale>0} {
#@       set val [expr $s_unit_scale/$t_unit_scale]
#@     }
#@   }
#@  
#@   return $val
#@   
#@ }
#@ 
#@ define_proc_attributes get_scale \
#@     -info " Get the scaling value from source library to target unit." \
#@     -define_args {
#@       {type "Unit type" type one_of_string {required value_help {values {time voltage current power capacitance resistance energy}}}}
#@       {target_unit "The target unit for scaling" target_unit string required }
#@       {library "The source library object" library list required}
#@ }
#@ 
#@ # -- End source /usr/cad/synopsys/lc/2022.12-sp6/auxx/lc/get_scale.tcl

#@ source $synopsys_root/auxx/lc/plot_table.tcl
#@ # -- Starting source /usr/cad/synopsys/lc/2022.12-sp6/auxx/lc/plot_table.tcl

#@ ##############################################################################
#@ # 'global' parameters   Author: Synopsys   Date: 2016/9/18
#@ ##############################################################################
#@ 
#@ # temp path to accommodate plot data and script 
#@ set lc_plot_table_base_dir  "/tmp/lc_plot_table_"
#@ set lc_plot_table_list_dirs  ""  ;# a list for tmp dirs
#@ 
#@ # to accommodate PIDs & COMMANDs of xterm being executed
#@ set lc_plot_table_pids      ""
#@ set lc_plot_table_cmds      ""
#@ 
#@ ##############################################################################
#@ # Proc: createUniqueDir   Author: Synopsys   Date: 2016/9/18
#@ #   create one unique folder (without tailing backslash) under temp path
#@ # Return: 
#@ #   path of the created folder
#@ ##############################################################################
#@ proc createUniqueDir {} {
#@   set sDir [pid]
#@   append sDir "_" [clock microseconds]
#@   file mkdir $::lc_plot_table_base_dir$sDir
#@   lappend ::lc_plot_table_list_dirs $sDir
#@   return $::lc_plot_table_base_dir$sDir
#@ }
#@ # This proc is hidden
#@ define_proc_attributes createUniqueDir -hidden
#@ 
#@ ##############################################################################
#@ # Proc: clearSpot   Author: Synopsys   Date: 2016/9/18
#@ #   delete the previous intermediate gnuplot data and script
#@ ##############################################################################
#@ proc clearSpot {} {
#@   # close the previous opened terminals
#@   set i 0
#@   foreach sPid $::lc_plot_table_pids {
#@     # check if pid existed
#@     if { [catch {exec kill -0 $sPid}]==0 } {
#@       set sCmd [lindex $::lc_plot_table_cmds $i]
#@       # check if the COMMAND of the pid is exactly the "xterm ..." which was forked by 'me' (plot_table)  
#@       if { [catch {exec ps u | awk {{for(ii=11;ii<=NF;ii++)printf $ii" ";printf "\n"}} | grep -e ^$sCmd}]==0 } {
#@         # kill the process
#@         catch {exec kill $sPid} msg
#@       }
#@     }    
#@     
#@     incr i
#@   }
#@   set ::lc_plot_table_pids  ""
#@   set ::lc_plot_table_cmds  ""
#@   
#@   # delete the previous intermediate gnuplot data and script
#@   foreach sDir $::lc_plot_table_list_dirs {
#@     file delete -force $::lc_plot_table_base_dir$sDir
#@   }
#@   set ::lc_plot_table_list_dirs  ""
#@ }
#@ # This proc is hidden
#@ define_proc_attributes clearSpot -hidden
#@ 
#@ ##############################################################################
#@ # Proc: genPlotData   Author: Synopsys   Date: 2016/10/28
#@ #   generate plot data
#@ # Arguments:
#@ #   lut     lookup_table object
#@ #   sDat    path of plot data file
#@ #   vSlice  slice info. e.g. "" (no slice specified); "output_voltage 0.0920645"
#@ #   vTol    tolerance curves or surfaces
#@ # Return:
#@ #   1 proc succeeded, 0 otherwise
#@ ##############################################################################
#@ proc genPlotData { lut sDat vSlice vTol } {
#@   if [catch {open $sDat w} pDat] {
#@     puts "error, failed to open $sDat for write:$pDat"
#@     return 0
#@   }
#@ 
#@   set nDim [lookup_table dimension $lut]
#@   set vIdx [lookup_table index $lut]
#@   set k 0
#@   
#@   if { [llength $vSlice] == 0 } {
#@     set vVal [lookup_table slice -all $lut]
#@     set vIdx0 [lindex $vIdx 0]
#@     if { $nDim==2 } {
#@       set vIdx1 [lindex $vIdx 1]
#@       foreach i $vIdx0 {
#@         foreach j $vIdx1 {
#@           set v [lindex $vVal $k]
#@           puts -nonewline $pDat "$i $j $v"
#@           foreach sTol $vTol {
#@             regsub -all "V" $sTol $v sTol
#@             puts -nonewline $pDat " [expr $sTol]"
#@           }
#@           puts $pDat ""
#@           incr k
#@         }
#@         puts $pDat ""
#@       }
#@     } else {
#@       foreach i $vIdx0 {
#@         set v [lindex $vVal $k]
#@         puts -nonewline $pDat "$i $v"
#@         foreach sTol $vTol {
#@           regsub -all "V" $sTol $v sTol
#@           puts -nonewline $pDat " [expr $sTol]"
#@         }
#@         puts $pDat ""
#@         incr k
#@       }
#@     }
#@   } else {
#@     set vVal [lookup_table slice $lut -index $vSlice]
#@     if { [string equal [lindex $vSlice 0] [lindex [lookup_table variables $lut] 0]] } {
#@       set vIdxAnother [lindex $vIdx 1]
#@     } else {
#@       set vIdxAnother [lindex $vIdx 0]
#@     }
#@     foreach i $vIdxAnother {
#@       set v [lindex $vVal $k]
#@       puts -nonewline $pDat "$i $v"
#@       foreach sTol $vTol {
#@         regsub -all "V" $sTol $v sTol
#@         puts -nonewline $pDat " [expr $sTol]"
#@       }
#@       puts $pDat ""
#@       incr k
#@     }
#@   }
#@   
#@   close $pDat
#@   return 1
#@ }
#@ # This proc is hidden
#@ define_proc_attributes genPlotData -hidden
#@ 
#@ ##############################################################################
#@ # Proc: genPlotDataForCcs   Author: Synopsys   Date: 2016/10/21
#@ #   generate plot data file for CCS object
#@ # Arguments:
#@ #   lut               lookup_table CCS object
#@ #   sDat              path of plot data file
#@ #   vVarIdx           grid points of the object e.g. {var1 index1 var2 index2}
#@ #   fInitV1           Vss(Vdd) as initial V1 for derived voltage
#@ #   vTol              tolerance curves
#@ #   sOvExpr(up-level) customized equation to derive voltage, it will be set to 
#@ #                     empty if invalid expression. This makes 
#@ #                     genPlotDataForCcsPlotAll() comfortable
#@ # Return:
#@ #   1 proc succeeded, 0 otherwise
#@ ##############################################################################
#@ proc genPlotDataForCcs { lut sDat vVarIdx fInitV1 vTol } {
#@   upvar sOvExpr sOvExprRef
#@   
#@   if [catch {open $sDat w} pDat] {
#@     puts "error, failed to open $sDat for write:$pDat"
#@     return 0
#@   }
#@   
#@   set fLoad -1.0
#@   if { [string equal [lindex $vVarIdx 0] "total_output_net_capacitance"]} {
#@     set fLoad [lindex $vVarIdx 1]
#@   } elseif { [string equal [lindex $vVarIdx 2] "total_output_net_capacitance"]} {
#@     set fLoad [lindex $vVarIdx 3]
#@   }
#@   
#@   set fVpre $fInitV1
#@   set fI 0.0
#@   set fIpre 0.0
#@   set fT 0.0
#@   set fTpre 0.0
#@   set fV 0.0
#@   
#@   set fTRef [lookup_table slice $lut -data ref -index $vVarIdx]
#@   if { [string length $fTRef]==0 } {
#@     set fTRef 0.0
#@   }
#@   if { [string equal $fTRef "0.0"] } {
#@     set fLoad -1.0
#@   }
#@   set vT [lookup_table slice $lut -data time -index $vVarIdx]
#@   set vI [lookup_table slice $lut -data values -index $vVarIdx]
#@   set nT [llength $vT]
#@   set nI [llength $vI]
#@   if { $nT!=$nI } {
#@     puts "error, size of time ($nT) != size of values ($nI)"
#@     close $pDat
#@     return 0
#@   }
#@   
#@   for { set i 0 } { $i<$nT } { incr i } {
#@     set fT [expr [lindex $vT $i]-$fTRef]
#@     set fI [lindex $vI $i]
#@     if { $fLoad > 0 } {
#@       if { [string length $sOvExprRef]!=0 } {
#@         set sOvExprTmp $sOvExprRef
#@         regsub -all "V1" $sOvExprTmp $fVpre sOvExprTmp
#@         regsub -all "I2" $sOvExprTmp $fI sOvExprTmp
#@         regsub -all "I1" $sOvExprTmp $fIpre sOvExprTmp
#@         regsub -all "T2" $sOvExprTmp $fT sOvExprTmp
#@         regsub -all "T1" $sOvExprTmp $fTpre sOvExprTmp
#@         regsub -all "C" $sOvExprTmp $fLoad sOvExprTmp
#@         if { [string length $sOvExprTmp]==0 } {
#@           set fExpr ""
#@         } else {
#@           set fExpr [expr $sOvExprTmp]
#@         }
#@         if { [string length $fExpr]==0 } {
#@           echo "warning, failed to get result of the process($sOvExprRef) from predefined variables: V1($fVpre), I2($fI), I1($fIpre), T2($fT), T1($fTpre), C($fLoad).\nTurn to use built-in default process(V1+0.5/C*(I2+I1)*(T2-T1))."
#@           set sOvExprRef "" ;# make genPlotDataForCcsPlotAll() comfortable
#@           set fV [expr $fVpre+0.5*($fI+$fIpre)*($fT-$fTpre)/$fLoad]
#@         } else {
#@           set fV $fExpr
#@         }
#@       } else {
#@         set fV [expr $fVpre+0.5*($fI+$fIpre)*($fT-$fTpre)/$fLoad]
#@       }
#@       set fVpre $fV
#@       set fIpre $fI
#@       set fTpre $fT
#@     } else {
#@       # "total_output_net_capacitance" is not there?
#@       # or no calculated voltage at all
#@       set fV 0.0
#@     }
#@     puts -nonewline $pDat "$fT $fI $fV"
#@     foreach sTol $vTol {
#@       regsub -all "V" $sTol $fI sTol
#@       puts -nonewline $pDat " [expr $sTol]"
#@     }
#@     puts $pDat ""
#@   }
#@   
#@   close $pDat
#@   return 1
#@ }
#@ # This proc is hidden
#@ define_proc_attributes genPlotDataForCcs -hidden
#@ 
#@ ##############################################################################
#@ # Proc: genPlotDataForCcsPlotAll   Author: Synopsys   Date: 2016/10/21
#@ #   generate plot data files for all grid points of the CCS object
#@ # Arguments:
#@ #   lut               lookup_table CCS object
#@ #   sFnPrefix         folder (with tailing backslash) to accommodate data file
#@ #   sOvExpr           customized equation to derive voltage
#@ #   fInitV1           Vss(Vdd) as initial V1 for derived voltage
#@ #   vTol              tolerance curves
#@ #   vDat(up-level)    paths of plot data files
#@ # Return:
#@ #   1 proc succeeded, 0 otherwise
#@ ##############################################################################
#@ proc genPlotDataForCcsPlotAll { lut sFnPrefix sOvExpr fInitV1 vTol } {
#@   # set an alias of up-level parameter, which will point to the same memory of
#@   # the parameter in up-level proc. (I think this is most like using reference
#@   # as function parameter in C++)
#@   upvar vDat vDatRef
#@   set vDatRef ""
#@ 
#@   set vVar [lookup_table variables $lut]  ;# e.g. "input_net_transition total_output_net_capacitance"
#@   set vIdx [lookup_table index $lut]      ;# e.g. "{0.00114139996003 0.00220229988918 ...} {......}"
#@   
#@   # 1d and 2d lookup tables supported by now, sanity check already done in main
#@   # procedure
#@   set nDim [llength $vVar]
#@   ## if { $nDim < 1 || $nDim > 2 } {
#@   ##   return -code error "...\n"
#@   ## }
#@   
#@   set sVar0 [lindex $vVar 0]
#@   set nIdx0Size [llength [lindex $vIdx 0]]
#@   
#@   if { $nDim > 1 } {
#@     set sVar1 [lindex $vVar 1]
#@     set nIdx1Size [llength [lindex $vIdx 1]]
#@   }
#@   
#@   for { set i 0 } { $i<$nIdx0Size } { incr i } {
#@     set fIdx0 [lindex [lindex $vIdx 0] $i]
#@     if { $nDim==1 } {
#@       set sDat $sFnPrefix
#@       append sDat "lut" [expr $i+1] ".dat"
#@       set vVarIdx [ list $sVar0 $fIdx0 ]
#@       set ret [genPlotDataForCcs $lut $sDat $vVarIdx $fInitV1 $vTol]
#@       if { $ret==0 } {
#@         return 0
#@       }
#@       lappend vDatRef $sDat
#@     } elseif { $nDim==2 } {
#@       for { set j 0 } { $j<$nIdx1Size } { incr j } {
#@         set fIdx1 [lindex [lindex $vIdx 1] $j]
#@         set sDat $sFnPrefix
#@         append sDat "lut" [expr $i*$nIdx1Size+$j+1] ".dat"
#@         set vVarIdx [ list $sVar0 $fIdx0 $sVar1 $fIdx1 ]
#@         set ret [genPlotDataForCcs $lut $sDat $vVarIdx $fInitV1 $vTol]
#@         if { $ret==0 } {
#@           return 0
#@         }
#@         lappend vDatRef $sDat
#@       }
#@     } ;# else 3d ...
#@   }
#@   
#@   return 1
#@ }
#@ # This proc is hidden
#@ define_proc_attributes genPlotDataForCcsPlotAll -hidden
#@ 
#@ ##############################################################################
#@ # Proc: getInfoString   Author: Synopsys   Date: 2016/10/27
#@ #   get information of lookup_table object
#@ # Arguments:
#@ #   lut               lookup_table object
#@ # Return:
#@ #   information string of the object
#@ ##############################################################################
#@ proc getInfoString { lut } {
#@   set sInfo ""
#@   
#@   set sTmpl [lookup_table template_name $lut]
#@   if { [string length $sTmpl]!=0 } {
#@     append sInfo " template(" $sTmpl ")"
#@   }
#@   
#@   set nDim [lookup_table dimension $lut]
#@   set vSize [lookup_table sizes $lut]
#@   if { $nDim>0 } {
#@     append sInfo " size(" [lindex $vSize 0]
#@   }
#@   if { $nDim>1 } {
#@     append sInfo "x" [lindex $vSize 1]
#@   }
#@   if { $nDim>2 } {
#@     append sInfo "x" [lindex $vSize 2]
#@   }
#@   if { $nDim>0 } {
#@     append sInfo ")"
#@   }
#@ 
#@   return $sInfo
#@ }
#@ # This proc is hidden
#@ define_proc_attributes getInfoString -hidden
#@ 
#@ ##############################################################################
#@ # Proc: printFile   Author: Synopsys   Date: 2016/11/25
#@ #   print out file content
#@ # Arguments:
#@ #   sDat               file path
#@ # Return:
#@ #   1 proc succeeded, 0 otherwise
#@ ##############################################################################
#@ proc printFile { sDat } {
#@   set sDelimit "################################################################################"
#@ 
#@   puts ""
#@   if [catch {open $sDat r} pDat] {
#@     puts "error, failed to open $sDat for read:$pDat"
#@     return 0
#@   }
#@   puts -nonewline "# "
#@   puts [file tail $sDat]
#@   puts $sDelimit
#@   puts [read $pDat]
#@   puts $sDelimit
#@   close $pDat      
#@ 
#@   return 1
#@ }
#@ # This proc is hidden
#@ define_proc_attributes printFile -hidden
#@ 
#@ ##############################################################################
#@ # Proc: plot_table   Author: Synopsys   Date: 2016/9/18
#@ #   plot lookup table(s) in lc_shell, using 'gnuplot'.
#@ # Arguments:
#@ #   see define_proc_attributes section 
#@ # Return:
#@ #   1 proc succeeded, 0 or error code otherwise
#@ # Examples:
#@ #   moved to man page: plot_table.3
#@ ##############################################################################
#@ proc plot_table {args} {
#@   # supported after set lc_enable_plot_table true
#@   if { [info exists ::lc_enable_plot_table]!=1 || [string equal -nocase $::lc_enable_plot_table "true"]!=1 } {
#@     return -code error "UIL-100 (error) The command is not enabled. You need to set lc_enable_plot_table beforehand."
#@     ## return ""  ;# well, dummy returned here if not set the enable_variable...
#@   }
#@   # supported in lc_advanced_tcl_mode
#@   if { [info exists ::lc_advanced_tcl_mode]!=1 || [string equal -nocase $::lc_advanced_tcl_mode "true"]!=1 } {
#@     return -code error "UIL-100 (error) The command is not enabled, it's support in advanced tcl mode only."
#@   }
#@   set i 0
#@   
#@   # get the args
#@   parse_proc_arguments -args $args ra
#@   
#@   # -clear, which is an individual arg
#@   if { [string length [array names ra -clear]] != 0 } {
#@     clearSpot
#@     return "1"
#@   }
#@   
#@   # create one more unique dir for data/script
#@   set sFnPrefix [createUniqueDir]
#@   append sFnPrefix "/"
#@   
#@   # luts: list of lookup tables, which is the main arg
#@   set vLut ""
#@   if { [string length [array names ra luts]] != 0 } {
#@     set vLut $ra(luts)
#@   }
#@   set nObjSize [llength $vLut]
#@   if {$nObjSize < 1} {
#@     return -code error "No lookup table is specified.\n"
#@   }
#@  
#@   #
#@   # sanity check and preparation
#@   #
#@   set bIsCCS 0
#@   set bIsCCSPlotAll 0
#@   set vSlice ""
#@   set nDim 0
#@   set sDat ""
#@   set vDat ""   ;# filenames of data
#@   foreach lut $vLut {
#@     set vSize [lookup_table sizes $lut] ;# e.g. "8" (1d), "8 7" (2d)
#@     if {[llength $vSize] < 1} {
#@       return -code error "Specified object ($lut) is NOT a lookup table.\n"
#@     }
#@     
#@     set nDimTmp [lookup_table dimension $lut]
#@     if { $nDimTmp < 1 || $nDimTmp > 2 } {
#@       # 1d and 2d lookup tables supported by now
#@       return -code error "Not supported for $nDimTmp dimension(s).\n"
#@     }
#@     if {[llength [lookup_table slice $lut -all]] < 1} {
#@       # this is a CCS object
#@       set nDim $nDimTmp
#@       if {$nObjSize > 1} {
#@         return -code error "Multiple lookup tables are not supported for CCS object\n"
#@       }
#@       set bIsCCS 1
#@       # -index, used to specify one slice of CCS object
#@       set vVarIdx ""
#@       if { [string length [array names ra -index]] != 0 } {
#@         set vVarIdx $ra(-index)
#@       }
#@       set nVarIdxSize [llength $vVarIdx]
#@       if { $nVarIdxSize==0 } {
#@         set bIsCCSPlotAll 1
#@       } elseif { $nVarIdxSize==1 } {
#@         # e.g. "0:0"  --> "input_net_transition 0.00726140011102 total_output_net_capacitance 0.000390200002585"
#@         # e.g. "0"    --> "input_net_transition 0.00726140011102"
#@         set vId [split $vVarIdx ":"]
#@         if {[llength $vId] != $nDim} {
#@           return -code error "Specified index ($vVarIdx) is unmatched with the object of $nDim dimension(s).\n"
#@         }
#@         set vVar [lookup_table variables $lut]
#@         set vIdx [lookup_table index $lut]
#@         if { $nDim==1 } {
#@           set vVarIdx [ list [lindex $vVar 0] \
#@             [lindex [lindex $vIdx 0] [expr [lindex $vId 0]]] ]
#@         } elseif { $nDim==2 } {
#@           set vVarIdx [ list [lindex $vVar 0] \
#@             [lindex [lindex $vIdx 0] [expr [lindex $vId 0]]] \
#@             [lindex $vVar 1] \
#@             [lindex [lindex $vIdx 1] [expr [lindex $vId 1]]] ]
#@         } ;# else 3d ...
#@       } ;# else more than 1 elements in $vVarIdx, leave check to lookup_table. e.g. "input_net_transition 0.00726140011102"
#@     } else {
#@       # this is NOT a CCS object
#@       if { $i > 0 } {
#@         if { $nDimTmp != $nDim } {
#@           return -code error "Different dimension(s) of multiple lookup tables can't be plotted at once.\n"
#@         }
#@         if { [llength $vSlice] != 0 } {
#@           # we assume user uses -slice for multi objects with exactly same index 
#@           if { [llength [lookup_table slice $lut -index $vSlice]] == 0 } {
#@             return -code error "Invalid -slice($vSlice), abort.\n"
#@           }
#@         }
#@       } else {  ;# $i==0
#@         set nDim $nDimTmp
#@         # -slice, used to specify one slice for (non-CCS) 2D lookup tables
#@         if { [string length [array names ra -slice]] != 0 } {
#@           set vSlice $ra(-slice)
#@           if { $nDim!=2 } {
#@             return -code error "-slice($vSlice) is not supported for ($nDim) dimension(s) lookup table, abort.\n"
#@           }
#@           set nSliceSize [llength $vSlice]
#@           if { $nSliceSize==1 } {
#@             # e.g. "0:0"    --> "input_voltage 0.0" (for dc_current)
#@             # e.g. "1:2"    --> "output_voltage 0.0920645"
#@             set vId [split $vSlice ":"]
#@             if {[llength $vId] != 2} {
#@               return -code error "Exactly 2 parts(variable_id:index_id) is needed for -slice($vSlice), abort.\n"
#@             }
#@             set nVarId [expr [lindex $vId 0]]
#@             set nIdxId [expr [lindex $vId 1]]
#@             if { $nVarId<0 || $nVarId>1 } {
#@               return -code error "Only 0 or 1 can be specified for the variable_id(the part before ':') in -slice($vSlice), abort.\n"
#@             }
#@             set vVar [lookup_table variables $lut]  ;# e.g. input_voltage output_voltage
#@             set vIdxN [lindex [lookup_table index $lut] $nVarId]  ;# e.g. {0.0 0.0434696 ... 0.95}
#@             if { $nIdxId<0 || $nIdxId>=[llength $vIdxN] } {
#@               return -code error "Invalid index_id(the part after ':') in -slice($vSlice), abort.\n"
#@             }
#@             set vSlice [ list [lindex $vVar $nVarId] [lindex $vIdxN $nIdxId] ]
#@           } elseif { $nSliceSize==2 } {
#@             if { [llength [lookup_table slice $lut -index $vSlice]] == 0 } {
#@               return -code error "Invalid -slice($vSlice), abort.\n"
#@             }
#@           } else {
#@             return -code error "Invalid -slice($vSlice), abort.\n"
#@           }
#@         }
#@       }
#@     }
#@     if { $bIsCCSPlotAll==0 } {
#@       # prepare filename(s) for data
#@       # this job will be done in genPlotDataForCcsPlotAll for 'ccs-plot-all' 
#@       set sDat $sFnPrefix
#@       append sDat "lut" [expr $i+1] ".dat"
#@       lappend vDat $sDat
#@     }
#@     incr i
#@   }
#@   # -dump sanity check
#@   set bDumpDat 0
#@   set bDumpDem 0
#@   if { [string length [array names ra -dump]] != 0 } {
#@     set sDumpOption $ra(-dump)
#@     if { [string equal $sDumpOption "data"] } {
#@       set bDumpDat 1
#@     } elseif { [string equal $sDumpOption "script"] } {
#@       set bDumpDem 1
#@     } elseif { [string equal $sDumpOption "all"] } {
#@       set bDumpDat 1
#@       set bDumpDem 1
#@     } else {
#@       return -code error "-dump $sDumpOption does not match [ data | script | all ].\n"
#@     }
#@   }
#@  
#@   # -derive_output_voltage, enable voltage curve for CCS object
#@   set bOmitExpr 1
#@   if { [string length [array names ra -derive_output_voltage]] != 0 } {
#@     set bOmitExpr 0
#@   }
#@   if { $bOmitExpr==0 && $bIsCCS==0 } {
#@     echo "warning, -derive_output_voltage option won't work for non-CCS objects, ommitted.\n"
#@     set bOmitExpr 1
#@   }
#@ 
#@   # -derive_output_voltage_equation
#@   set sOvExpr ""  ;# customized expression, empty if N/A or invalid
#@   if { $bOmitExpr==0 && [string length [array names ra -derive_output_voltage_equation]] != 0 } {
#@     set sOvExpr $ra(-derive_output_voltage_equation)
#@   }
#@   
#@   # -legend, to customize legends
#@   set itLegend ""
#@   if { [string length [array names ra -legend]] != 0 } {
#@     set itLegend $ra(-legend) ;# it* is actually list_*
#@   }
#@   set vLegend ""              ;# v* is also list_*
#@   set sLegend ""
#@ 
#@   # -initv1, Vss(Vdd) as initial V1 for derived voltage
#@   set fInitV1 0.0
#@   if { [string length [array names ra -initv1]] != 0 } {
#@     set fInitV1 $ra(-initv1)
#@   }
#@   
#@   # -tol, to add tolerance curves or surfaces, currently +-*/ supported
#@   set vTol ""
#@   if { [string length [array names ra -tol]] != 0 } {
#@     set itEq $ra(-tol)
#@     set i 0
#@     foreach sEq $itEq {
#@       set sEqTmp $sEq
#@       regsub -all "V" $sEqTmp -1.67345 sEqTmp
#@       if { [string length $sEqTmp]==0 } {
#@         set fExpr ""
#@       } else {
#@         set fExpr [expr $sEqTmp]
#@       }
#@       if { [string length $fExpr]!=0 } {
#@         lappend vTol $sEq
#@       } else {
#@         echo "warning, no.[expr $i+1] -tol equation($sEq) is invalid and omitted. Currently, arithmetic operations(+-*/) are supported. The variable name V is used as the default independent variables.\n"
#@       }
#@       incr i
#@     }
#@   }
#@ 
#@   #
#@   # generate data, prepare legends for plotting
#@   #
#@   set i 0
#@   foreach lut $vLut {
#@     if { $bIsCCSPlotAll==1 } {
#@       set ret [genPlotDataForCcsPlotAll $lut $sFnPrefix $sOvExpr $fInitV1 $vTol]
#@     } elseif { $bIsCCS==1 } {
#@       set ret [genPlotDataForCcs $lut [lindex $vDat 0] $vVarIdx $fInitV1 $vTol]
#@     } else {
#@       set ret [genPlotData $lut [lindex $vDat $i] $vSlice $vTol]
#@     }
#@     if { $ret==0 } {
#@       return 0
#@     }
#@ 
#@     # initialize legend for non-CCS object(s)
#@     if { $bIsCCS==0 } {
#@       if { [string length [lindex $itLegend $i]]!=0 } {
#@         set sLegend [lindex $itLegend $i]
#@         # speical characters needs to be converted
#@         regsub -all {\\} $sLegend {\\\\} sLegend
#@         regsub -all "\"" $sLegend "\\\"" sLegend
#@       } else {
#@         set sLegend "lut"
#@         append sLegend [expr $i+1]
#@       }
#@       append sLegend [getInfoString $lut]
#@       if { [llength $vSlice]!=0 } {
#@         append sLegend " slice"
#@       }
#@       lappend vLegend $sLegend
#@     }
#@     incr i
#@   }
#@   # initialize legends for CCS object
#@   if { $bIsCCS==1 } {
#@     for { set i 0 } { $i<2 } { incr i } {
#@       if { [string length [lindex $itLegend $i]]!=0 } {
#@         set sLegend [lindex $itLegend $i]
#@         # speical characters needs to be converted
#@         regsub -all {\\} $sLegend {\\\\} sLegend
#@         regsub -all "\"" $sLegend "\\\"" sLegend
#@       } else {
#@         if { $i==0 } {
#@           set sLegend "y= current"
#@         } elseif { [string length $sOvExpr]==0 } {
#@           set sLegend "y2= V1+0.5/C*(I2+I1)*(T2-T1)"
#@         } else {
#@           set sLegend "y2= $sOvExpr"
#@         }
#@       }
#@       lappend vLegend $sLegend
#@     }
#@   }
#@   
#@   # -aux, to add auxiliary curves or surfaces, currently +-*/ supported
#@   set sAuxAppend ""
#@   if { [string length [array names ra -aux]] != 0 } {
#@     set itEq $ra(-aux)
#@     set i 0
#@     foreach sEq $itEq {
#@       set sEqTmp $sEq
#@       regsub -all "X" $sEqTmp -1.67345 sEqTmp
#@       if { $nDim==2 && [llength $vSlice]==0 } {
#@         regsub -all "Y" $sEqTmp 864.195 sEqTmp
#@       }
#@       if { [string length $sEqTmp]==0 } {
#@         set fExpr ""
#@       } else {
#@         set fExpr [expr $sEqTmp]
#@       }
#@       if { [string length $fExpr]!=0 } {
#@         append sAuxAppend "," $sEq
#@         if { $bIsCCS==1 } {
#@           append sAuxAppend " title \"y= $sEq\" axes x1y1"  ;# plot auxiliaries to 1st Y-Axis for CCS
#@         }
#@       } else {
#@         echo "warning, no.[expr $i+1] -aux equation($sEq) is invalid and omitted. Currently, arithmetic operations(+-*/) are supported. The variable names X and Y are used as the default independent variables. Additionally, Y is only supported for 2 dimension tables.\n"
#@       }
#@       incr i
#@     }
#@   }
#@   # -aux2, to add auxiliary curves to 2nd Y-Axis for CCS only, currently +-*/ supported
#@   if { [string length [array names ra -aux2]] != 0 } {
#@     set itEq $ra(-aux2)
#@     set i 0
#@     foreach sEq $itEq {
#@       set sEqTmp $sEq
#@       regsub -all "X" $sEqTmp -1.67345 sEqTmp
#@       if { $nDim==2 && [llength $vSlice]==0 } {
#@         regsub -all "Y" $sEqTmp 864.195 sEqTmp
#@       }
#@       if { [string length $sEqTmp]==0 } {
#@         set fExpr ""
#@       } else {
#@         set fExpr [expr $sEqTmp]
#@       }
#@       if { [string length $fExpr]!=0 } {
#@         if { $bIsCCS==1 } {
#@           append sAuxAppend "," $sEq
#@           append sAuxAppend " title \"y2= $sEq\" axes x1y2"  ;# plot auxiliaries to 2nd Y-Axis for CCS only
#@         }
#@       } else {
#@         echo "warning, no.[expr $i+1] -aux2 equation($sEq) is invalid and omitted. Currently, arithmetic operations(+-*/) are supported. The variable names X and Y are used as the default independent variables. Additionally, Y is only supported for 2 dimension tables.\n"
#@       }
#@       incr i
#@     }
#@   }
#@   
#@   # -title, -xlabel, -ylabel, -y2label, several simple 'string' arguments
#@   set sTitle ""
#@   if { [string length [array names ra -title]] != 0 } {
#@     set sTitle $ra(-title)
#@   }
#@   set sXlabel ""
#@   if { [string length [array names ra -xlabel]] != 0 } {
#@     set sXlabel $ra(-xlabel)
#@   }
#@   set sYlabel ""
#@   if { [string length [array names ra -ylabel]] != 0 } {
#@     set sYlabel $ra(-ylabel)
#@   }
#@   set sY2label ""
#@   if { [string length [array names ra -y2label]] != 0 } {
#@     set sY2label $ra(-y2label)
#@   }
#@   
#@   #
#@   # generate main script 'lut.dem'
#@   #
#@   set sDem $sFnPrefix
#@   append sDem "lut.dem"
#@   if [catch {open $sDem w} pDem] {
#@     puts "error, failed to open $sDem for write:$pDem"
#@     return 0
#@   }
#@   puts $pDem "reset"  ;# reset graph-related options to default
#@   if { [string length $sAuxAppend]!=0 } {
#@     if { $bIsCCS==0 && $nDim==2 && [llength $vSlice]==0 } {
#@       puts $pDem "set dummy X,Y"
#@     } else {
#@       puts $pDem "set dummy X"
#@     }
#@   }
#@   if { $bIsCCSPlotAll==1 } {
#@     if { [string length $sTitle]!=0 } {
#@       append sTitle "\\n"
#@     }
#@     append sTitle [lindex $vLegend 0]
#@     if { $bOmitExpr==0 } {
#@       append sTitle " vs. " [lindex $vLegend 1]
#@     }
#@     append sTitle [getInfoString $lut]
#@     puts -nonewline $pDem "set multiplot title \"$sTitle\" layout [lindex $vSize 0],"
#@     if { $nDim==1 } {
#@       puts $pDem "1"
#@     } elseif { $nDim==2 } {
#@       puts $pDem "[lindex $vSize 1]"
#@     } ;# else 3d ... (e.g. 5*8*7, maybe 5 windows popped-up?)
#@     puts $pDem "unset border\nunset tics\nunset key"
#@     foreach sDat $vDat {
#@       puts -nonewline $pDem "plot \'$sDat\' u 1:2 with lines"
#@       if { $bOmitExpr==0 } {
#@         puts -nonewline $pDem ", \'$sDat\' u 1:3 with lines axes x1y2"
#@       }
#@       set nTolId 4  ;# tolerance data begin at 4th column for CCS object
#@       foreach sTol $vTol {
#@         puts -nonewline $pDem ", \'$sDat\' u 1:$nTolId with lines"
#@         incr nTolId
#@       }
#@       puts $pDem " $sAuxAppend"
#@     }
#@     puts $pDem "unset multiplot"
#@   } elseif { $bIsCCS==1 } {
#@     puts $pDem "set ytics nomirror"
#@     puts $pDem "set y2tics"
#@     if { [string length $sTitle]!=0 } {
#@       append sTitle "\\n"
#@     }
#@     foreach vectorVarIndex_i $vVarIdx {
#@       append sTitle $vectorVarIndex_i " "
#@     }
#@     puts $pDem "set title \"$sTitle\""
#@     if { [string length $sXlabel]==0 } {
#@       set sXlabel "time_adjust(T=time-reference_time)"
#@     }
#@     puts $pDem "set xlabel \'$sXlabel\'"
#@     if { [string length $sYlabel]==0 } {
#@       set sYlabel "current(I=vVal)"
#@     }
#@     puts $pDem "set ylabel \'$sYlabel\'"
#@     if { $bOmitExpr==0 } {
#@       if { [string length $sY2label]==0 } {
#@         set sY2label "Vout"
#@       }
#@       puts $pDem "set y2label \'$sY2label\'"
#@     }
#@     puts -nonewline $pDem "plot \'[lindex $vDat 0]\' using 1:2 with linespoints title \"[lindex $vLegend 0]\""
#@     if { $bOmitExpr==0 } {
#@       puts -nonewline $pDem ", \'[lindex $vDat 0]\' using 1:3 with linespoints title \"[lindex $vLegend 1]\" axes x1y2"
#@     }
#@     set nTolId 4  ;# tolerance data begin at 4th column for CCS object
#@     foreach sTol $vTol {
#@       puts -nonewline $pDem ", \'[lindex $vDat 0]\' u 1:$nTolId with linespoints title \"[lindex $vLegend 0] $sTol\""
#@       incr nTolId
#@     }
#@     puts $pDem " $sAuxAppend"
#@   } else {
#@     if { [llength $vSlice]!=0 } {
#@       if { [string length $sTitle]!=0 } {
#@         append sTitle "\\n"
#@       }
#@       append sTitle "slice(" $vSlice ")"
#@     }
#@     if { [string length $sTitle]!=0 } {
#@       puts $pDem "set title \"$sTitle\""
#@     }
#@     if { $nDim==2 && [llength $vSlice]==0 } {
#@       # Synopsys 18:29 2016/10/28
#@       # !!!LOOK OUT!!! in next line the letter before 'nonewline' is a 'â€“' which
#@       # is NOT A CORRECT dash symbol '-':
#@       ## puts â€“nonewline $pDem "set hidden3d\n"
#@       puts $pDem "set hidden3d"
#@       # removed -nogrid, raw data is shown as default, jizhan, Sep 13 2017
#@       ## if { [string length [array names ra -nogrid]] == 0 } {
#@       ##   puts $pDem "set dgrid3d 50,50,4"
#@       ## }
#@       # the following line may 'hide' xyplane at start-up of plot, so comment it out
#@       ## puts $pDem "set xyplane at 0.0"
#@     }
#@     if { $nDim==2 } {
#@       if { [string length $sYlabel]==0 } {
#@         set vVar [lookup_table variables $lut]
#@         set sYlabel [lindex $vVar 1]
#@       }
#@     }
#@     if { [string length $sXlabel]==0 } {
#@       set vVar [lookup_table variables $lut]
#@       set sXlabel [lindex $vVar 0]
#@     }
#@     if { [llength $vSlice]!=0 } {
#@       if { [string equal [lindex $vSlice 0] [lindex [lookup_table variables $lut] 0]] } {
#@         puts $pDem "set xlabel \'$sYlabel\'"
#@       } else {
#@         puts $pDem "set xlabel \'$sXlabel\'"
#@       }
#@     } else {
#@       puts $pDem "set xlabel \'$sXlabel\'"
#@       if { [string length $sYlabel]!=0 } {
#@         puts $pDem "set ylabel \'$sYlabel\'"
#@       }
#@     }
#@     if { $nDim==2 && [llength $vSlice]==0 } {
#@       puts -nonewline $pDem "splot "
#@       set nTolBgnId 4   ;# tolerance data begin at 4th column for 3D plot
#@     } else {
#@       puts -nonewline $pDem "plot "
#@       set nTolBgnId 3   ;# tolerance data begin at 3rd column for 2D plot
#@     }
#@     for { set i 0 } { $i<$nObjSize } { incr i } {
#@       if { $i>0 } {
#@         puts -nonewline $pDem ", "
#@       }
#@       puts -nonewline $pDem "\'[lindex $vDat $i]\' with linespoints title \"[lindex $vLegend $i]\""
#@       set nTolId $nTolBgnId
#@       foreach sTol $vTol {
#@         if { $nTolBgnId==4 } {
#@           puts -nonewline $pDem ", \'[lindex $vDat $i]\' using 1:2:$nTolId with linespoints title \"[lindex $vLegend $i] $sTol\""
#@         } else {
#@           puts -nonewline $pDem ", \'[lindex $vDat $i]\' using 1:$nTolId with linespoints title \"[lindex $vLegend $i] $sTol\""
#@         }
#@         incr nTolId
#@       }
#@     }
#@     puts $pDem "$sAuxAppend"
#@   }
#@   close $pDem
#@ 
#@   #
#@   # generate a wrapper script 'lut.demw', which sets env. and loads 'lut.dem'
#@   #
#@   set sDemw $sFnPrefix
#@   append sDemw "lut.demw"
#@   if [catch {open $sDemw w} pDemw] {
#@     puts "error, failed to open $sDemw for write:$pDemw"
#@     return 0
#@   }
#@   # save to image file (you need to plot-to-file before plot-to-X11, only 
#@   # the last one being plotted is interactivable!)
#@   set sImgFile ""
#@   if { [string length [array names ra -save]] != 0 } {
#@     set sImgFile $ra(-save)
#@   }
#@   set sCurDir [pwd]
#@   if { [string length $sImgFile]!=0 } {
#@     puts $pDemw "set term png small"
#@     if { [string equal [file pathtype $sImgFile] "absolute"] } {
#@       puts $pDemw "set output \'$sImgFile\'"
#@     } else {
#@       puts $pDemw "set output \'$sCurDir/$sImgFile\'"
#@     }
#@     puts $pDemw "load \'$sDem\'"
#@   }
#@   puts $pDemw "set term X11"    ;# to plot to X11
#@   puts $pDemw "load \'$sDem\'"
#@ 
#@   close $pDemw
#@   
#@   #
#@   # execute 'gnuplot' or dump data/script
#@   #
#@   if { $bDumpDat==0 && $bDumpDem==0 } {
#@     cd $sFnPrefix
#@     lappend ::lc_plot_table_pids [exec xterm -e "gnuplot $sDemw -" &]
#@     lappend ::lc_plot_table_cmds "xterm -e gnuplot $sDemw - "
#@     cd $sCurDir
#@   } else {
#@     if { $bDumpDat==1 } {
#@       foreach sDat $vDat {
#@         printFile $sDat
#@       }
#@     }
#@     if { $bDumpDem==1 } {
#@       printFile $sDem
#@       printFile $sDemw
#@     }
#@   }
#@   
#@   return 1
#@ }
#@ # This proc is hidden by now
#@ define_proc_attributes plot_table -hidden \
#@     -info "plot lookup table(s) by gnuplot." \
#@     -define_args {
#@       {luts "lookup table object variables" "object_list" list optional}
#@       {-aux "add auxiliary curves or surfaces by equations" "equation_list" list optional}
#@       {-aux2 "add auxiliary curves aligning to 2nd Y-Axis for CCS only" "equation_list" list optional}
#@       {-derive_output_voltage "add output voltage curve which is derived upon default equation: V1+0.5*(I2+I1)*(T2-T1)/C" "" boolean optional}
#@       {-derive_output_voltage_equation "customize the equation to derive output voltage curve" "equation" string optional}
#@       {-initv1 "provide Vss(Vdd) as initial V1 for derived voltage" "Vss(Vdd)" string optional}
#@       {-index "define grid points for CCS only" "{variable1 index1 variables2 index2}|index1_id:index2_id" string optional}
#@       {-title "title for the plot chart" "title" string optional}
#@       {-xlabel "label of x-axis for the plot chart" "xlabel" string optional}
#@       {-ylabel "label of y-axis for the plot chart" "ylabel" string optional}
#@       {-y2label "label of y2-axis for the plot chart" "y2label" string optional}
#@       {-legend "legends for lookup table" "legend_list" list optional}
#@       {-save "save to image file in png format" "png_file_path" string optional}
#@       {-clear "close all opened terminals and remove all intermediate data" "" boolean optional}
#@       {-dump "print out data and/or scripts generated, instead of plot them" "data|script|all" string optional}
#@       {-slice "plot one slice for (non-CCS) 2D lookup tables" "{variable index}|variable_id:index_id" string optional}
#@       {-tol "add tolerance curves or surfaces by equations" "equation_list" list optional}
#@ }
#@ ## {-nogrid "disable grid data mapping (to 50x50) for 3D data, show original data instead" "" boolean optional}
#@ # -- End source /usr/cad/synopsys/lc/2022.12-sp6/auxx/lc/plot_table.tcl

#@ source $synopsys_root/auxx/lc/report_check_library_records.tcl
#@ # -- Starting source /usr/cad/synopsys/lc/2022.12-sp6/auxx/lc/report_check_library_records.tcl

#@ ##############################################################################
#@ # 'global' parameters   Author: Synopsys   Date: 2020/9/18
#@ ##############################################################################
#@ array set libchk_code_array { 
#@              1 LIBCHK-300 2 LIBCHK-301 3 LIBCHK-303 4 LIBCHK-304 5 LIBCHK-307 
#@              6 LIBCHK-310 7 LIBCHK-311 8 LIBCHK-312 9 LIBCHK-313 10 LIBCHK-314 
#@              11 LIBCHK-320 12 LIBCHK-321 13 LIBCHK-322 14 LIBCHK-323 15 LIBCHK-330 
#@              16 LIBCHK-331 17 LIBCHK-340 18 LIBCHK-341 19 LIBCHK-342 20 LIBCHK-343 
#@              21 LIBCHK-344 22 LIBCHK-345 23 LIBCHK-345 24 LIBCHK-346 25 LIBCHK-347 
#@              26 LIBCHK-350 27 LIBCHK-352 28 LIBCHK-353 29 LIBCHK-354 30 LIBCHK-355 
#@              31 LIBCHK-356 32 LIBCHK-357 33 LIBCHK-358 34 LIBCHK-359 35 LIBCHK-365 
#@              36 LIBCHK-210 37 LIBCHK-211 38 LIBCHK-212 39 LIBCHK-212 40 LIBCHK-213 
#@              41 LIBCHK-214 42 LIBCHK-215 43 LIBCHK-216 44 LIBCHK-217 45 LIBCHK-201
#@              46 LIBCHK-112}
#@ 
#@ # libchk_code_array, sql_full_table_array and sql_full_table_description is 1:1 map
#@ proc get_index_for_libchk_code {libchk_code} {
#@   global libchk_code_array
#@   
#@   set idx ""
#@   set i 0
#@   set code ""
#@   # skip LIBCHK-307 it is internal table
#@   if {$libchk_code == "LIBCHK-307"} { 
#@     return $idx;
#@   }
#@   foreach {i code} [array get libchk_code_array] {
#@     #puts "The corresponding number of $i is $code."
#@     if {$code == $libchk_code} {
#@       lappend idx $i
#@     }
#@   }
#@   return $idx
#@ }
#@ define_proc_attributes get_index_for_libchk_code -hidden 
#@ 
#@ proc get_sql_full_table_by_idx {idx} {
#@   array set sql_full_table_array {1 libchk300_mismatched_libs_slg \
#@                                 2 libchk301_operating_cond  \
#@                                 3 libchk303_missing_libs_slg \
#@                                 4 libchk304_scaling_lib_groups \
#@                                 5 libchk307_misc \
#@                                 6 libchk310_missing_cells_slg \
#@                                 7 libchk311_mismatched_cells_slg \
#@                                 8 libchk312_cell_classification \
#@                                 9 libchk313_missing_hvth \
#@                                 10 libchk314_mb_vs_sb_cells \
#@                                 11 libchk320_missing_pins_slg \
#@                                 12 libchk321_mismatched_pins_slg \
#@                                 13 libchk322_mismatched_pg_pins_slg \
#@                                 14 libchk323_missing_pg_pins_slg \
#@                                 15 libchk330_missing_arcs \
#@                                 16 libchk331_mismatched_arcs \
#@                                 17 libchk340_noise_model \
#@                                 18 libchk341_power_model \
#@                                 19 libchk342_ccsn_vs_nldm \
#@                                 20 libchk343_sensitivity \
#@                                 21 libchk344_value_range \
#@                                 22 libchk345_pg_current_ratio \
#@                                 23 libchk345_ccsp_time_ratio \
#@                                 24 libchk346_ccsn_vs_ccst \
#@                                 25 libchk347_c1cn_vs_c1c2 \
#@                                 26 libchk350_ccst_vs_nldm \
#@                                 27 libchk352_lvf \
#@                                 28 libchk353_stats_analysis \
#@                                 29 libchk354_table_trend \
#@                                 30 libchk355_table_bound \
#@                                 31 libchk356_table_slope \
#@                                 32 libchk357_table_index \
#@                                 33 libchk358_interpolation \
#@                                 34 libchk359_voltage_range \
#@                                 35 libchk365_summary \
#@                                 36 libchk210_missing_logic_cells \
#@                                 37 libchk211_missing_phys_cells \
#@                                 38 libchk212_missing_logic_pins \
#@                                 39 libchk212_missing_phys_pins \
#@                                 40 libchk213_mismatched_pins \
#@                                 41 libchk214_bus_naming_style \
#@                                 42 libchk215_cell_footprint \
#@                                 43 libchk216_mismatched_cell_area \
#@                                 44 libchk217_mismatched_cells \
#@                                 45 libchk201_library_list \
#@                                 46 libchk112_same_name_cells}
#@ 
#@   set full_table ""
#@   set sz [llength $idx]
#@   for {set i 0} {$i < $sz} {incr i} {
#@     set ii [lindex $idx $i]
#@     lappend full_table $sql_full_table_array($ii)
#@   }
#@   return $full_table
#@ }
#@ define_proc_attributes get_sql_full_table_by_idx -hidden 
#@ 
#@ proc get_description_for_table_by_idx {idx} {
#@ array set sql_full_table_description {
#@   1 {List of inconsistent library group data (LIBCHK-300)}  \
#@   2 {List of incompliant operating conditions (LIBCHK-301)} \
#@   3 {Missing libraries in scaling groups (LIBCHK-303)} \
#@   4 {Valid scaling library groups (LIBCHK-304)}  \
#@   5 {List of miscellaneous inconsistent library data (LIBCHK-307)} \
#@   6 {List of cells missing in logic libraries (LIBCHK-310)} \
#@   7 {List of cells with mismatched or missing attributes in logic libraries (LIBCHK-311)} \
#@   8 {List of cell classification (LIBCHK-312)} \
#@   9 {List of function groups missing high threshold_voltage_group cells (LIBCHK-313)} \
#@   10 {List of mapping multi bit to single bit cells (LIBCHK-314)} \
#@   11 {List of pins missing in logic libraries (LIBCHK-320)} \
#@   12 {List of pins with mismatched or missing attributes in logic libraries (LIBCHK-321)} \
#@   13 {List of pg_pins with mismatched or missing attributes in logic libraries (LIBCHK-322)} \
#@   14 {List of pg_pins missing in logic libraries (LIBCHK-323)} \
#@   15 {List of timing arcs missing or existing in libraries (LIBCHK-330)} \
#@   16 {List of timing arcs mismatched in logic libraries (LIBCHK-331)} \
#@   17 {List of inconsistent CCS noise models (LIBCHK-340)} \
#@   18 {List of inconsistent power models (LIBCHK-341)} \
#@   19 {List of inconsistent data between CCS noise and NLDM models (LIBCHK-342)} \
#@   20 {List of sensitive CCSN models (LIBCHK-343)} \
#@   21 {Table of attribute value range analysis (LIBCHK-344)} \
#@   22 {Table of pg current value ratios. (LIBCHK-345)} \
#@   23 {Table of ccsp time value ratios. (LIBCHK-345)} \
#@   24 {List of inconsistent data between CCS noise and CCS timing models (LIBCHK-346)} \
#@   25 {List of inconsistent receiver_capacitance C1/C2 (LIBCHK-347)} \
#@   26 {List of inconsistent data between different timing models (LIBCHK-350)} \
#@   27 {Table of LVF model analysis (LIBCHK-352)} \
#@   28 {Report of the statistical analysis results of characterization models (LIBCHK-353)}  \
#@   29 {Table of characterization table trend analysis (LIBCHK-354)} \
#@   30 {Table of characterization table bound analysis (LIBCHK-355)} \
#@   31 {Table of characterization table slope analysis (LIBCHK-356)} \
#@   32 {Table of characterization table index analysis (LIBCHK-357)} \
#@   33 {Table of interpolation accuracy analysis (LIBCHK-358)} \
#@   34 {Table of partial voltage ranges on timing arcs (LIBCHK-359)} \
#@   35 {Statistical analysis summary table (LIBCHK-365)} \
#@   36 {List of cells missing in logic library (LIBCHK-210)} \
#@   37 {List of cells missing in physical library (LIBCHK-211)} \
#@   38 {List of pins missing in logic library (LIBCHK-212)} \
#@   39 {List of pins missing in physical library (LIBCHK-212)} \
#@   40 {List of pins mismatched in logic and physical libraries (LIBCHK-213)} \
#@   41 {List of bus naming styles (LIBCHK-214)} \
#@   42 {List of cells with cell_footprint attribute (LIBCHK-215)} \
#@   43 {List of cells with inconsistent area (LIBCHK-216)} \
#@   44 {List of cells mismatched in logic and physical libraries (LIBCHK-217)} \
#@   45 {List of logic and physical libraries} \
#@   46 {List of cells with same names (LIBCHK-112)}}
#@   set desp ""
#@   set sz [llength $idx]
#@   for {set i 0} {$i < $sz} {incr i} {
#@     set ii [lindex $idx $i]
#@     lappend desp $sql_full_table_description($ii)
#@   }
#@   return $desp
#@ 
#@ }
#@ define_proc_attributes get_description_for_table_by_idx -hidden 
#@ 
#@ proc print_column_names_for_table {file_id tbl_info exclude_cols sep} {
#@   set sz [llength $tbl_info]
#@   set col [expr {$sz/6}]
#@   set num_cols 0
#@   set idx 0
#@   set col_names ""
#@   while {$idx < $col} {
#@     set one_col [lindex $tbl_info [expr $idx * 6 +1] ]
#@     # If $one_col is in $exclude_cols, do not add it to $col_names
#@     if {[lsearch -exact $exclude_cols $one_col] < 0} {
#@       if {$idx == 0} {
#@         set col_names $one_col
#@       } else {
#@         set col_names [concat $col_names$sep$one_col]
#@       }
#@       incr num_cols
#@     }
#@     incr idx
#@   }
#@ 
#@   if {[llength $file_id] > 0} {
#@       puts $file_id  $col_names
#@   }
#@   return [list $num_cols $col_names]
#@ }
#@ define_proc_attributes print_column_names_for_table -hidden 
#@ 
#@ proc print_records_for_table {file_id arr num_col sep} {
#@   set sz [expr [llength $arr]/$num_col]
#@   for {set i 0} {$i < $sz} {incr i} {
#@     set val ""
#@     for {set j 0} {$j < $num_col} {incr j} {
#@       set val1 [lindex $arr [expr $i*$num_col+$j]]   
#@       if {$j == 0} {
#@         set val $val1
#@       } else {  
#@         set val [concat $val$sep$val1]  
#@       } 
#@     }
#@     puts $file_id $val
#@   }
#@ }
#@ define_proc_attributes print_records_for_table -hidden 
#@ 
#@ proc print_table {tbl_name {print_line ""}} {
#@     set tbl_struct [db3 eval "pragma table_info($tbl_name)"]
#@     set cols [print_column_names_for_table "" $tbl_struct "" ","]
#@     set num_cols [lindex $cols 0]
#@     set line_len [expr $num_cols*18]			
#@     set line_sep [string repeat "-" $line_len]
#@     set arr1 [db3 eval "select * from $tbl_name"]
#@     if {$print_line != ""} { puts stdout $line_sep }
#@     print_column_names_for_table stdout $tbl_struct "" "\t"
#@     if {$print_line != ""} { puts stdout $line_sep }
#@     print_records_for_table stdout $arr1 $num_cols "\t"
#@     if {$print_line != ""} { puts stdout $line_sep }
#@ }
#@ define_proc_attributes print_table -hidden
#@ 
#@ ##############################################################################
#@ # Proc: report_check_library_records Author: Synopsys   Date: 2020/9/2
#@ #   This command is to report library checking results stored in sqlite database
#@ # Arguments:
#@ #   see define_proc_attributes section 
#@ # Return:
#@ #   1 proc succeeded, 0 or error code otherwise
#@ ##############################################################################
#@ proc report_check_library_records {args} {
#@   # get the args
#@   parse_proc_arguments -args $args ra
#@   set options ""
#@   set lc_advanced_tcl_mode true
#@   set sql_file $ra(sql_filename)
#@   set verbose ""
#@   if {[string length [array names ra -verbose]] != 0} {
#@     set verbose  1
#@   }
#@   # list of sql tables to report
#@   # sql_table_list and desp_list should 1:1 map 
#@   set sql_table_list ""
#@   global libchk_code_array
#@   set support_table_list ""
#@   foreach {index code} [array get libchk_code_array] {
#@     set support_table_list [concat $support_table_list $code]
#@   }
#@   set desp_list ""
#@   set libchk_code_defined 0
#@   set char_integrity_defined 0
#@   set logic_defined 0
#@   set logic_vs_physical_defined 0
#@   if {[string length [array names ra -libchk_codes]] != 0} {
#@     set error_codes $ra(-libchk_codes)
#@     set libchk_code_defined 1 
#@     if {[llength $error_codes] < 1} {
#@       return -code error "-libchk_codes should be a list of libchk error code, in the format of LIBCHK-3XX or LIBCHK-2XX\n"
#@     }
#@     foreach code $error_codes {
#@       set idx [get_index_for_libchk_code $code]
#@       if {[llength $idx] < 1 } {
#@         puts "Warning : Ignore invalid libchk_code $code!\n"
#@         puts "Supported libchk_codes are : $support_table_list\n"
#@ 
#@         continue
#@       }
#@       set full_table [get_sql_full_table_by_idx $idx]
#@       if {[llength $full_table] <1} {
#@         # make sure code and table is consistent
#@         puts "Warning : Ignore invalid libchk_code $code!\n"
#@         puts "Supported libchk_codes are : $support_table_list\n"
#@         continue
#@       }
#@       set tmp_desp [get_description_for_table_by_idx $idx]
#@       foreach tbl $full_table {
#@         set sql_table_list [concat $sql_table_list $tbl]
#@         set desp_list [concat $desp_list $tmp_desp]
#@       }
#@     }
#@   }
#@       
#@   if {[string length [array names ra -char_integrity]] != 0} {
#@     set char_integrity_defined 1 
#@     lappend sql_table_list "libchk342_ccsn_vs_nldm"
#@     lappend sql_table_list "libchk343_sensitivity"
#@     lappend sql_table_list "libchk350_ccst_vs_nldm"
#@     lappend sql_table_list "libchk358_interpolation"
#@     lappend sql_table_list "libchk359_voltage_range"
#@     lappend desp_list [get_description_for_table_by_idx 19]
#@     lappend desp_list [get_description_for_table_by_idx 20]
#@     lappend desp_list [get_description_for_table_by_idx 26]
#@     lappend desp_list [get_description_for_table_by_idx 33]
#@     lappend desp_list [get_description_for_table_by_idx 34]
#@   }
#@   if {[string length [array names ra -logic]] != 0} {
#@     set logic_defined 1 
#@     lappend sql_table_list "libchk300_mismatched_libs_slg"
#@     lappend sql_table_list "libchk301_operating_cond"
#@     lappend sql_table_list "libchk303_missing_libs_slg"
#@     lappend sql_table_list "libchk304_scaling_lib_groups"
#@     lappend sql_table_list "libchk310_missing_cells_slg"
#@     lappend sql_table_list "libchk311_mismatched_cells_slg"
#@     lappend sql_table_list "libchk312_cell_classification"
#@     lappend sql_table_list "libchk313_missing_hvth"
#@     lappend sql_table_list "libchk314_mb_vs_sb_cells"
#@     lappend sql_table_list "libchk320_missing_pins_slg"
#@     lappend sql_table_list "libchk321_mismatched_pins_slg"
#@     lappend sql_table_list "libchk322_mismatched_pg_pins_slg"
#@     lappend sql_table_list "libchk323_missing_pg_pins_slg"
#@     lappend sql_table_list "libchk330_missing_arcs"
#@     lappend sql_table_list "libchk331_mismatched_arcs"
#@     lappend sql_table_list "libchk340_noise_model"
#@     lappend sql_table_list "libchk341_power_model"
#@     lappend sql_table_list "libchk347_c1cn_vs_c1c2"
#@     lappend desp_list [get_description_for_table_by_idx 1]
#@     lappend desp_list [get_description_for_table_by_idx 2]
#@     lappend desp_list [get_description_for_table_by_idx 3]
#@     lappend desp_list [get_description_for_table_by_idx 4]
#@     lappend desp_list [get_description_for_table_by_idx 6]
#@     lappend desp_list [get_description_for_table_by_idx 7]
#@     lappend desp_list [get_description_for_table_by_idx 8]
#@     lappend desp_list [get_description_for_table_by_idx 9]
#@     lappend desp_list [get_description_for_table_by_idx 10]
#@     lappend desp_list [get_description_for_table_by_idx 11]
#@     lappend desp_list [get_description_for_table_by_idx 12]
#@     lappend desp_list [get_description_for_table_by_idx 13]
#@     lappend desp_list [get_description_for_table_by_idx 14]
#@     lappend desp_list [get_description_for_table_by_idx 15]
#@     lappend desp_list [get_description_for_table_by_idx 16]
#@     lappend desp_list [get_description_for_table_by_idx 17]
#@     lappend desp_list [get_description_for_table_by_idx 18]
#@     lappend desp_list [get_description_for_table_by_idx 25]
#@ 
#@   }
#@   if {[string length [array names ra -logic_vs_physical]] != 0} {
#@     set logic_vs_physical_defined 1 
#@     lappend sql_table_list "libchk201_library_list"
#@     lappend sql_table_list "libchk210_missing_logic_cells"
#@     lappend sql_table_list "libchk211_missing_phys_cells"
#@     lappend sql_table_list "libchk212_missing_logic_pins"
#@     lappend sql_table_list "libchk212_missing_phys_pins"
#@     lappend sql_table_list "libchk213_mismatched_pins"
#@     lappend sql_table_list "libchk214_bus_naming_style"
#@     lappend sql_table_list "libchk215_cell_footprint"
#@     lappend sql_table_list "libchk216_mismatched_cell_area"
#@     lappend sql_table_list "libchk217_mismatched_cells"
#@     lappend desp_list [get_description_for_table_by_idx 45]
#@     lappend desp_list [get_description_for_table_by_idx 36]
#@     lappend desp_list [get_description_for_table_by_idx 37]
#@     lappend desp_list [get_description_for_table_by_idx 38]
#@     lappend desp_list [get_description_for_table_by_idx 39]
#@     lappend desp_list [get_description_for_table_by_idx 40]
#@     lappend desp_list [get_description_for_table_by_idx 41]
#@     lappend desp_list [get_description_for_table_by_idx 42]
#@     lappend desp_list [get_description_for_table_by_idx 43]
#@     lappend desp_list [get_description_for_table_by_idx 44]
#@   }
#@   # by default output summary from 312, 310, 353 table
#@   if {[llength $sql_table_list] < 1} {
#@     set sql_table_list "libchk312_cell_classification"
#@     lappend sql_table_list "libchk310_missing_cells_slg"
#@     lappend sql_table_list "libchk353_stats_analysis"
#@     set desp_list [get_description_for_table_by_idx 8]
#@     lappend desp_list [get_description_for_table_by_idx 6]
#@     lappend desp_list [get_description_for_table_by_idx 28]
#@   }
#@   if {$libchk_code_defined == 1 }  {
#@      if {$char_integrity_defined == 1} {
#@        return -code error "Error : Cannot specify '-libchk_codes' with '-char_integrity'.(CMD-001)\n"
#@      }
#@ # removed following to enable LIBCHK-112 with -logic -logic_vs_physical
#@ #     if {$logic_defined == 1} {
#@ #       return -code error "Error : Cannot specify '-libchk_codes' with '-logic'.(CMD-001)\n"
#@ #     }
#@ #     if {$logic_vs_physical_defined == 1} {
#@ #       return -code error "Error : Cannot specify '-libchk_codes' with '-logic_vs_physical'.(CMD-001)\n"
#@ #     }
#@   }
#@ 
#@   set cell_list ""
#@   if  {[string length [array names ra -cells]] != 0} {
#@     set cell_list $ra(-cells)
#@     if {[llength $cell_list] < 1} {
#@       return -code error "-cells should be a list of cell names\n"
#@     }
#@   }
#@   set sql_cmd ""
#@   if  {[string length [array names ra -sql_cmd]] != 0} {
#@     set sql_cmd $ra(-sql_cmd)
#@   }
#@   set cell_num [llength $cell_list]
#@   set cell_filter ""
#@   if {$cell_num > 0} {
#@     set idx 0
#@     while {$idx < $cell_num} {
#@       set one_cell "'[lindex $cell_list $idx]'"
#@       if {$idx == 0} {
#@         set cell_filter  $one_cell
#@       } else {
#@         set cell_filter [concat $cell_filter,$one_cell]
#@       }
#@       incr idx
#@     }
#@   }
#@   set cell_clause ""
#@   if {$cell_filter != ""} {
#@     if {$sql_cmd == ""} {
#@         set cell_clause "where cell_name in ($cell_filter)"
#@     } else {
#@         set cell_clause "and cell_name in ($cell_filter)"
#@     }
#@   }
#@   set output_csv 0
#@   if  {[string length [array names ra -report_format]] != 0} {
#@     set format $ra(-report_format)
#@     if {$format != "csv"} {
#@       return -code error "only \"-report_format csv\" is supported."
#@     }
#@     set output_csv 1
#@   }
#@ 
#@   #open sqlite database
#@   sqlite3 db3 $sql_file
#@   puts "\nInformation: Open $sql_file for reporting.\n"
#@ 
#@   set desp_i  0
#@   foreach full_table $sql_table_list {
#@     set tbl_exist [db3 eval "pragma table_info($full_table)"]
#@     set one_desp [string trim [lindex $desp_list $desp_i] "{}"]
#@     incr desp_i
#@     set add_cell_filter_clause 1
#@     #make sure the table has "cell_name" column
#@     if {[lsearch $tbl_exist "cell_name"] < 0} {
#@       set add_cell_filter_clause 0
#@     }
#@ 
#@     set sz [llength $tbl_exist]
#@     if {$sz > 0} {
#@       set col_num [expr {$sz/6}]
#@       set arr1 ""
#@       if {$add_cell_filter_clause == 1 && $cell_clause != ""} {
#@         set arr1 [db3 eval "select * from $full_table $sql_cmd $cell_clause "]
#@         #puts "select * from $full_table $sql_cmd $cell_clause "
#@       } else {
#@         set arr1 [db3 eval "select * from $full_table $sql_cmd"]
#@         #puts "select * from $full_table $sql_cmd "
#@       }
#@ 
#@       set num_records [llength $arr1]
#@       if {$num_records > 0} {
#@         set line_len [expr $col_num*18]
#@         if {$line_len > 140} {
#@           set line_len 140
#@         }
#@         set line_sep [string repeat "-" $line_len]
#@         puts $one_desp 
#@         puts $line_sep
#@         print_column_names_for_table stdout $tbl_exist "" "\t"
#@         puts $line_sep
#@         print_records_for_table stdout $arr1 $col_num "\t"
#@         puts $line_sep
#@         if {$output_csv == 1} {
#@           set out_file [concat out_$full_table.csv]
#@           set file_id [open $out_file w]
#@           print_column_names_for_table $file_id $tbl_exist "" ","
#@           write_records_in_csv $file_id $arr1 $col_num
#@           close $file_id
#@         }
#@       } else {
#@         puts "Warning: no record is print! Please check -sql_cmd is correct if specified!"
#@       }
#@     } elseif {$verbose == 1 || $sql_cmd != ""} {
#@        puts "Warning : Table $full_table does not exist."
#@     }
#@   }
#@   # list all sqlite table names
#@   if {[string length [array names ra -sql_table_list]] != 0} {
#@       set tbl_names [db3 eval "SELECT name FROM sqlite_master"]
#@       puts "The database has [llength $tbl_names] sqlite tables:"
#@       puts stdout $tbl_names
#@   }
#@   db3 close
#@ }
#@ 
#@ define_proc_attributes report_check_library_records \
#@     -info "report check library results" \
#@     -define_args {
#@       {sql_filename "report check library result from the sql database file" "file_name" string required}
#@       {-cells "report check library result for specified cells" "cell_list" list optional}
#@       {-libchk_codes "report check library result for specified LIBCHK codes" "libchk_code_list" list optional}
#@       {-char_integrity "report check library result for char integrity" "" boolean optional}
#@       {-logic "report check library result for logical" "" boolean optional}
#@       {-logic_vs_physical "report check library result for logic vs. physical check" "" boolean optional}
#@       {-sql_cmd "sql command to evaluate in sqlite" "sql_command" string optional}
#@       {-sql_table_list "list all sqlite table names" "" boolean optional}
#@       {-report_format "output file format" "csv" string optional} 
#@       {-verbose "output detail running log" "" boolean optional}
#@ }
#@ 
#@ ################################################################################
#@ # Proc: update_check_library_records Author: Synopsys   Date: 03/01/2021
#@ #   This proc is for incremental updates on fusion libraries:
#@ #   1) remove records for libraries specified in -remove_libs
#@ #   2) merge check library records from sql_filename2 to sql_filename
#@ # Arguments:
#@ #   see define_proc_attributes section 
#@ # Return:
#@ #   1 proc succeeded, 0 or error code otherwise
#@ ################################################################################
#@ 
#@ proc update_check_library_records {args} {
#@   # get the args
#@   parse_proc_arguments -args $args ra
#@   set options ""
#@   set lc_advanced_tcl_mode true
#@   set sql_file $ra(sql_filename)
#@   set verbose ""
#@   if {[string length [array names ra -verbose]] != 0} {
#@     set verbose 1
#@   }
#@ 
#@   if ![file exists $sql_file.bak] {
#@       exec cp $sql_file $sql_file.bak ;# back up original $sql_file if not done so
#@   }
#@ 
#@   set ::FLIB::added_phys_libs ""
#@   set ::FLIB::removed_phys_libs ""
#@   set ::FLIB::added_dbs ""
#@   set ::FLIB::removed_dbs ""
#@ 
#@   #open sqlite databases
#@   sqlite3 db3 $sql_file
#@   set sql_file2 ""			
#@   # open sql_filename2 and merge tables with sql_filename
#@   if {[string length [array names ra sql_filename2]] != 0} {
#@       set sql_file2 $ra(sql_filename2)
#@       if ![file exists $sql_file2.bak] {
#@ 	  exec cp $sql_file2 $sql_file2.bak ;# back up original $sql_file2
#@       }
#@       sqlite3 db3inc $sql_file2
#@       set ::FLIB::added_phys_libs [::FLIB::get_updated_libs "Physi\#" 1]
#@       set ::FLIB::added_dbs [::FLIB::get_updated_libs "Logic\#" 1]
#@   }
#@ 
#@   # map lib_no from inc_db3 to db3 via lib_name for libs replaced
#@   set lib_no_and_names  [db3 eval "select lib_no, lib_name from libchk201_library_list"] ;# Logic#1:lib_name
#@   array set ::FLIB::lib_name2nos [::FLIB::map_lib_name_to_no $lib_no_and_names];# from db3
#@   if {$sql_file2 != ""} {
#@     set tbl_exist [db3inc eval "pragma table_info(libchk201_library_list)"]
#@     if {[llength $tbl_exist] > 0} {
#@       set lib_no_and_names2 [db3inc eval "select lib_no, lib_name from libchk201_library_list"]
#@       array set ::FLIB::lib_no2names [::FLIB::map_lib_no_to_name $lib_no_and_names2] ;# from inc_db3
#@     }
#@   }
#@   set rm_libs ""
#@   if {[string length [array names ra -remove_libs]] != 0} {
#@       set rm_libs $ra(-remove_libs)
#@       # get lib# to lib_name mapping
#@       array set ::FLIB::lib_no2names0 [::FLIB::map_lib_no_to_name $lib_no_and_names]
#@       ::FLIB::remove_libs $rm_libs
#@       set ::FLIB::removed_phys_libs [::FLIB::get_removed_libs "Physi\#" $rm_libs]
#@       set ::FLIB::removed_dbs [::FLIB::get_removed_libs "Logic\#" $rm_libs]
#@   }
#@ 
#@   # open sql_filename2 and merge tables with sql_filename
#@   if {[string length $sql_file2] != 0} {
#@       puts "update_check_library_records $sql_file $sql_file2"
#@       ::FLIB::merge_tables $sql_file $sql_file2 $verbose ;# lib_name2nos lib_no2names
#@   }
#@ 
#@   # update autofix.tcl
#@   ::FLIB::update_autofix_tcl $sql_file $sql_file2
#@   if {$rm_libs != ""} {
#@       puts "update_check_library_records $sql_file $sql_file2 -remove_libs $rm_libs done."
#@   } else {
#@       puts "update_check_library_records $sql_file $sql_file2 done."
#@   }
#@   db3 close
#@ }
#@ 
#@ define_proc_attributes update_check_library_records \
#@     -hidden \
#@     -info "incrementally update check library results in sqlite3 (.db3)" \
#@     -define_args {
#@       {sql_filename "sql file for original check library results" "file_name" string required}
#@       {sql_filename2 "incrementally updated sql file" "file_name" string optional}
#@       {-remove_libs "db in lib[0-9]+ or frame lib name to be removed" "lib_list" list optional}
#@       {-verbose "output detailed check_lib records" "" boolean optional}
#@     }
#@ 
#@ # Get logic or physical lib names from LIBCHK-201 table
#@ # sql_file = autofix0.tcl
#@ # lib_type = 'Logic#' or 'Physi#'
#@ # return list of updated lib names by type or the whole libchk201 table
#@ proc get_lib_names {sql_file {lib_type ""}} {
#@     global flib_sql_list
#@     sqlite3 db3 $sql_file
#@     if {$lib_type == ""} {
#@ 	set flib_sql_list [db3 eval "select * from libchk201_library_list"]
#@     } else {
#@ 	set flib_sql_list [db3 eval "select lib_name from libchk201_library_list where lib_no like '${lib_type}%'"]
#@     }
#@     db3 close
#@     return $flib_sql_list
#@ }
#@ define_proc_attributes get_lib_names -hidden
#@ 
#@ proc get_sql_tables {sql_file} {
#@     global flib_sql_list
#@     sqlite3 db3 $sql_file
#@     set tbl_names [db3 eval "SELECT name FROM sqlite_master"]
#@     set flib_sql_list $tbl_names
#@     db3 close
#@     return $tbl_names
#@ }
#@ define_proc_attributes get_sql_tables -hidden
#@ 
#@ 
#@ namespace eval FLIB {
#@ 
#@ #remove records and/or columns for libraries specified in -remove_libs
#@ #also remove autofix lines if issue/record is gone
#@ proc remove_libs {rm_libs} {
#@     set where_cond [remove_lib_where $rm_libs]
#@     set where_cond_phys $where_cond
#@     regsub -all "lib_name" $where_cond_phys "phys_lib" where_cond_phys
#@     set where_cond_logic $where_cond
#@     regsub -all "lib_name" $where_cond_logic "logic_lib" where_cond_logic
#@ 
#@     set tbl_names0 [db3 eval "SELECT name FROM sqlite_master"]
#@     foreach tbl_name $tbl_names0 {
#@ 	if {$tbl_name == "libchk213_mismatched_pins"} {
#@ 	    remove_records_from_table $rm_libs $tbl_name
#@ 	    continue
#@ 	}
#@ 	set tbl_struct [db3 eval "pragma table_info($tbl_name)"]
#@ 	set cols [print_column_names_for_table "" $tbl_struct $rm_libs ","]
#@ 	#set num_cols [lindex $cols 0]
#@ 	set cols [lindex $cols 1]
#@ 	set where_cond2 [ neq_val_where $cols $rm_libs ] ;# e.g. where lib2!=lib1 or lib3!=lib1
#@ 
#@ 	#rename existing table
#@ 	db3 eval "ALTER TABLE $tbl_name RENAME TO ${tbl_name}_old"
#@ 	#create table with the original name
#@ 	if {[lsearch $tbl_struct "lib_name"] >= 0} { ;# if table has lib_name
#@ 	    db3 eval "CREATE TABLE $tbl_name AS SELECT $cols FROM ${tbl_name}_old $where_cond"
#@ 	} elseif {[lsearch $tbl_struct "phys_lib"] >= 0} { ;# if table has phys_lib, i.e. LIBCHK-210, 212
#@ 	    db3 eval "CREATE TABLE $tbl_name AS SELECT $cols FROM ${tbl_name}_old $where_cond_phys"
#@ 	} elseif {[lsearch $tbl_struct "logic_lib"] >= 0} { ;# if table has logic_lib, i.e. LIBCHK-211, 212
#@ 	    db3 eval "CREATE TABLE $tbl_name AS SELECT $cols FROM ${tbl_name}_old $where_cond_logic"
#@ 	} else {			# if record has inconsistent values in lib1, lib2, ...
#@ 	    db3 eval "CREATE TABLE $tbl_name AS SELECT $cols FROM ${tbl_name}_old $where_cond2"
#@ 	    # get consistent removed records in string patterns for scenario 1.2
#@ 	    db3 eval "DELETE FROM ${tbl_name}_old $where_cond2";# delete records stored in new $tbl_name above
#@ 	    variable removed_lines
#@ 	    set removed_lines [get_removed_records $tbl_name]
#@ 	}
#@ 	#remove empty table
#@ 	if {[db3 eval "SELECT COUNT(*) FROM $tbl_name"] == 0} {
#@ 	    db3 eval "drop table if exists $tbl_name"
#@ 	}
#@ 	db3 eval "drop table if exists ${tbl_name}_old";# remove old table after $tbl_name is updated
#@     }
#@ 
#@     if {[info exists db_removed] && $db_removed == 1} {		;# get $extra_db_cells_dbs_removed
#@ 	set tbl_struct [db3 eval "pragma table_info('libchk310_missing_cells_slg')"]
#@ 	set cols [print_column_names_for_table "" $tbl_struct $rm_libs ","]
#@ 	set cols [lindex $cols 1]
#@ 	get_extra_db_cells_dbs_removed "libchk310_missing_cells_slg" $cols $rm_libs
#@     }
#@ }
#@ define_proc_attributes remove_libs -hidden
#@ 
#@ # merge sqlite tables from sql_filename2 to sql_filename, so final tables will have more columns and/or records
#@ proc merge_tables {sql_file sql_file2 verbose} {
#@     db3 eval {attach database $sql_file2 as inc_db3}
#@     set tbl_names0 [db3 eval "SELECT name FROM sqlite_master"]
#@     set tbl_names2 [db3inc eval "SELECT name FROM sqlite_master"]
#@     set tbl_names [lsort -unique [list {*}$tbl_names0 {*}$tbl_names2]] ;# union of tbl names from db3 and db3inc
#@     foreach tbl_name $tbl_names {
#@ 	if {$tbl_name == "libchk210_missing_logic_cells" || $tbl_name == "libchk211_missing_phys_cells"} {
#@ 	    merge_table2 $tbl_name
#@ 	} elseif {[lsearch $tbl_names0 $tbl_name] >= 0 && [lsearch $tbl_names2 $tbl_name] >= 0} { ;# if both sql_file and sql_file2 have same name table 
#@ 	    merge_table $tbl_name $verbose
#@ 	} elseif {[lsearch $tbl_names2 $tbl_name] >= 0} { ;# if only sql_file2 has the table, copy it to sql_file
#@ 	    db3 eval "CREATE TABLE $tbl_name AS SELECT * FROM inc_db3.$tbl_name" ;# add to autofix.tcl
#@ 	}
#@ 	# if sql_file2 has no same name table, i.e. the table is only in sl_file, keep it in db3
#@     }
#@     if {$verbose == 1} {
#@ 	puts "The primary sql database $sql_file has [llength $tbl_names0] tables."
#@ 	puts "The second sql database $sql_file2 has [llength $tbl_names2] tables."
#@ 	puts "The merged sql database has [llength $tbl_names] tables:\n$tbl_names"
#@     }
#@ }
#@ define_proc_attributes merge_tables -hidden
#@ 		
#@ # if both sql_file and sql_file2 have same name table, merge it to sql_file
#@ proc merge_table {tbl_name verbose} {
#@     set tbl_struct [db3inc eval "pragma table_info($tbl_name)"]
#@     set tbl_struct0 [db3 eval "pragma table_info($tbl_name)"] ;# same name table in original sql_file
#@     set max_lib_no0 [get_max_lib_no $tbl_struct0];# max lib# in sql_file
#@     set cols00 [print_column_names_for_table "" $tbl_struct0 "" ","]
#@     set cols00 [lindex $cols00 1];	# all column name list in original sql_file
#@ 
#@     if {[regexp {.+ lib[0-9]+ .+} $tbl_struct]} { ;# if sql_file2 has same name table with lib1,lib2,..., merge it to $sql_file with new columns added 
#@ 	set max_lib_no [get_max_lib_no $tbl_struct] ;# max lib# in sql_file2
#@ 	set cols [print_column_names_for_table "" $tbl_struct "" ","]
#@ 	#set col_num [lindex $cols 0]
#@ 	set cols [lindex $cols 1]
#@ 	set cols0 $cols ;# all the column names in tbl_name in sql_file2
#@ 	#left join
#@ 	set cols [populate_lib_number_list $max_lib_no0 $max_lib_no "inc_db3.$tbl_name"];# inc_db3.$tbl_name. to lib2,lib3,...
#@ 	set cols00 [populate_column_list $cols00 "main.$tbl_name"]     ;# prefix main.$tbl_name to column names
#@ 	set col_names_selected [concat "$cols00" $cols]
#@ 	set on_cond [join_on_cond $tbl_name $cols0] ;# join on condition
#@ 	db3 eval "CREATE TABLE ${tbl_name}_left_join AS SELECT $col_names_selected from main.$tbl_name LEFT JOIN inc_db3.$tbl_name on $on_cond"
#@ 	#right join 
#@ 	regsub -all ",lib1,.+" $cols0 ",lib1," cols0 ;# remove lib2,lib3,...
#@ 	set cols0 [populate_column_list $cols0 "inc_db3.$tbl_name"]     ;# prefix inc_db3.$tbl_name to column names
#@ 	set cols1 [populate_lib_number_list 1 $max_lib_no0 "main.$tbl_name"];# $tbl_name.lib2, $tbl_name.lib3, ...
#@ 	set cols1 [concat $cols1 ",$cols"]
#@ 	set col_names_selected [concat $cols0 $cols1]
#@ 	db3 eval "CREATE TABLE ${tbl_name}_right_join AS SELECT $col_names_selected from inc_db3.$tbl_name LEFT JOIN main.$tbl_name on $on_cond"
#@ 	db3 eval "drop table if exists ${tbl_name}";# drop original table and use union table below instead
#@ 	#union left and right, i.e. merge original and incremental tables
#@ 	db3 eval "CREATE TABLE $tbl_name AS SELECT * FROM ${tbl_name}_left_join UNION SELECT * FROM ${tbl_name}_right_join"
#@ 	#populate records by value from lib1 
#@ 	set set_where [update_set_where $max_lib_no0]
#@ 	db3 eval "UPDATE $tbl_name SET $set_where AND lib1 IS NOT NULL" ;# case 1: add set_attribute to autofix.tcl
#@ 	db3 eval "drop table if exists ${tbl_name}_left_join"
#@ 	db3 eval "drop table if exists ${tbl_name}_right_join"
#@     } elseif {$tbl_name == "libchk201_library_list"} { ;# for libchk201 join/union with no duplciate lib_name
#@ 	set max_logic_num0 [get_max_lib_no_libchk201 "Logic\#" db3]    ;# max logic lib# in sql_file
#@ 	set max_logic_num  [get_max_lib_no_libchk201 "Logic\#" db3inc] ;# max logic lib# in sql_file2
#@ 	array set rep_lib_nos [map_replaced_lib_numbers $max_logic_num]  ;# replaced lib#'s map from incr to original LIBCHK-201
#@ 	set len [string length $max_logic_num0]
#@ 	set lib_num [format "%0*d" $len 1];# e.g. change Logic#1 to Logic#01
#@ 	db3inc eval "UPDATE $tbl_name SET lib_no = 'Logic\#$lib_num' WHERE lib_no = 'Logic\#1'"
#@ 	for {set i 2} {$i <= $max_logic_num} {incr i} { ;# increment lib_no's in db3inc
#@ 	    set lib_num [expr $max_logic_num0 + $i - 1]
#@ 	    if [info exists rep_lib_nos($i)] {# if replaced lib, take the original lib_num
#@ 		set lib_num $rep_lib_nos($i)
#@ 	    }
#@ 	    set lib_num [format "%0*d" $len $lib_num];# e.g. change Logic#2 to Logic#02
#@ 	    db3inc eval "UPDATE $tbl_name SET lib_no = 'Logic\#$lib_num' WHERE lib_no = 'Logic\#$i'"
#@ 	}
#@ 	union_table $tbl_name
#@ 	if {$verbose == 1} { 
#@ 	    print_table $tbl_name
#@ 	}
#@     } else {  ;# if sql_file2 has same name table without lib1,lib2,..., merge the records to $sql_file
#@ 	union_table $tbl_name
#@     }
#@     # remove empty table
#@     if {[db3 eval "SELECT COUNT(*) FROM $tbl_name"] == 0} {
#@ 	db3 eval "drop table if exists $tbl_name"
#@     }
#@ }
#@ define_proc_attributes merge_table -hidden
#@ 					
#@ # update LIBCHK-210, LIBCHK-211
#@ proc merge_table2 {tbl_name} {
#@     set tbl_struct [db3inc eval "pragma table_info($tbl_name)"]
#@     set tbl_struct0 [db3 eval "pragma table_info($tbl_name)"] ;# same name table in original sql_file
#@ 
#@     if {$tbl_name == "libchk210_missing_logic_cells"} { ;# update separately
#@ 	# remove duplicate cells from LIBCHK-210 if LIBCHK-112 exists
#@ 	set tbl_exist [db3inc eval "pragma table_info(libchk112_same_name_cells)"]
#@ 	if {[llength $tbl_exist] > 0} { # if LIBCHK-112 exists in db3inc
#@ 	    set dup_cells0 [db3inc eval " SELECT cell_name FROM libchk112_same_name_cells "]
#@ 	    #insert quote to each cell_name => 'cell_name' for sql
#@ 	    set dup_cells ""
#@ 	    foreach cell_name $dup_cells0 {lappend dup_cells "'$cell_name'"}
#@ 	    set where_in [join $dup_cells ","]
#@ 	    db3 eval "DELETE FROM $tbl_name WHERE cell_name IN ($where_in)"
#@ 	}
#@ 
#@ 	variable added_phys_libs
#@ 	variable removed_phys_libs
#@ 	if {[llength $added_phys_libs] > 0} {# frame added
#@ 	    union_table $tbl_name
#@ 	}
#@ 	if {[info exists removed_phys_libs] && [llength $removed_phys_libs] > 0 && [llength $tbl_struct0] > 0} {# frame removed
#@ 	    set extra_phys_cells [db3 eval " SELECT cell_name FROM $tbl_name "]
#@ 	    if {[db3 eval "SELECT COUNT(*) FROM $tbl_name"] == 0} {# if updated LIBCHK-210 is empty, then missing phys cells => final LIBCHK-211
#@ 		puts "Warning: Original db3 has LIBCHK-210. Need re-xcheck for libchk211_missing_phys_cells after removing frame files $removed_phys_libs."
#@ 	    }
#@ 	}
#@     } elseif {$tbl_name == "libchk211_missing_phys_cells"} { ;# update separately
#@ 	variable added_phys_libs
#@ 	variable missing_phys_cells
#@ 	set extra_db_cells [db3 eval " SELECT cell_name FROM $tbl_name "]
#@ 	set missing_phys_cells $extra_db_cells;# scenario 2.2
#@ 	if {[llength $tbl_struct] > 0 && [llength $added_phys_libs] > 0} {# frame added, Update autofix.tcl
#@ 	    set new_phys_cells [db3inc eval " SELECT cell_name FROM $tbl_name "]
#@ 	    # Xcheck cells in new frame vs. extra cells in dbs
#@ 	    # if $extra_db_cells > new_phys_cells, update LIBCHK-211 by removing records where cells in new frame
#@ 	    if {[llength $extra_db_cells] > [llength $new_phys_cells]} {# update autofix.tcl: change create_dummy_physical_cell to remove_physical_lib_cell on $new_phys_cells
#@ 		db3 eval "ALTER TABLE $tbl_name RENAME TO ${tbl_name}_old"
#@ 		#insert quote to each cell_name => 'cell_name' for sql
#@ 		set new_phys_cells2 ""
#@ 		foreach cell_name $new_phys_cells {lappend new_phys_cells2 "'$cell_name'"}
#@ 		set where_in [join $new_phys_cells2 ","]
#@ 		db3 eval "INSERT INTO $tbl_name SELECT * FROM ${tbl_name}_old WHERE cell_name NOT IN ($where_in)"
#@ 	    } elseif {[llength $tbl_struct] > 0} { # updated LIBCHK-211 is empty, then remaining cells = missing logic cells = incr LIBCHK-210 with extra db cells removed 
#@ 		db3 eval "drop table if exists $tbl_name"
#@ 		#insert quote to each cell_name => 'cell_name' for sql
#@ 		set extra_db_cells2 ""
#@ 		foreach cell_name $extra_db_cells {lappend extra_db_cells2 "'$cell_name'"}
#@ 		set where_in [join $extra_db_cells2 ","]
#@ 		db3 eval "INSERT INTO $tbl_name SELECT * FROM inc_db3.libchk210_missing_logic_cells WHERE cell_name NOT IN ($where_in)"
#@ 	    }
#@ 	    # get intersection of extra_db_cells and new_phys_cells for autofix
#@ 	    # scenario 3.1
#@ 	    variable flib_extra_cells
#@ 	    variable flib_missing_cells
#@ 	    set flib_extra_cells [list_intersect $extra_db_cells $new_phys_cells]
#@ 	    set flib_missing_cells [list_exclude $extra_db_cells $new_phys_cells]
#@ 	}
#@ 	if {[info exists removed_phys_libs] && [llength $removed_phys_libs] > 0} {# frame removed
#@ 	    #Get extra_db_cells from old LIBCHK-211
#@ 	    #Get removed cells in removed frame? 
#@ 	    #Add records where cell in removed frame into old LIBCHK-211 
#@ 	    puts "Warning: Original db3 has LIBCHK-211. Need re-xcheck for libchk211_missing_phys_cells after removing frame files $removed_phys_libs."
#@ 	}				
#@     }
#@ }
#@ define_proc_attributes merge_table2 -hidden
#@ 
#@ proc union_table {tbl_name} {
#@     db3 eval "CREATE TABLE ${tbl_name}_union AS SELECT * FROM $tbl_name UNION SELECT * FROM inc_db3.$tbl_name"
#@     db3 eval "drop table if exists $tbl_name"
#@     db3 eval "ALTER TABLE ${tbl_name}_union RENAME TO $tbl_name"
#@ }
#@ define_proc_attributes union_table -hidden
#@ 
#@ # map library number e.g. lib1 to library_name
#@ proc map_lib_no_to_name {lib_no_and_names} {
#@     array set arr ""
#@     set num_libs [llength $lib_no_and_names]
#@     for {set i 0} {$i < $num_libs} {incr i 2} {
#@ 	set lib_no   [ lindex $lib_no_and_names $i ]
#@ 	set lib_name [ lindex $lib_no_and_names [expr $i+1] ]
#@ 	regsub -all "Logic\#" $lib_no "lib" lib_no
#@ 	set arr($lib_no) $lib_name
#@ 	# lib01 and lib1 should both map to lib_name
#@ 	if [regexp {^lib[0-9]+} $lib_no] {# if lib#
#@ 	    regsub "^lib(0+)" $lib_no "lib" lib_no1;# remove leading 0's
#@ 	    if {[string compare $lib_no1 $lib_no] != 0} {# e.g. lib01 vs. lib1
#@ 		set arr($lib_no1) $lib_name
#@ 	    }
#@ 	}
#@     }
#@     return [array get arr]
#@ }
#@ define_proc_attributes map_lib_no_to_name -hidden
#@ 
#@ # map library_name to lib_no e.g. lib1
#@ proc map_lib_name_to_no {lib_no_and_names} {
#@     array set arr ""
#@     set num_libs [llength $lib_no_and_names];# 2x number of libs
#@     for {set i 0} {$i < $num_libs} {incr i 2} {
#@ 	set lib_no   [ lindex $lib_no_and_names $i ]
#@ 	set lib_name [ lindex $lib_no_and_names [expr $i+1] ]
#@ 	regsub -all "Logic\#" $lib_no "lib" lib_no
#@ 	set arr($lib_name) $lib_no
#@     }
#@     return [array get arr]
#@ }
#@ define_proc_attributes map_lib_name_to_no -hidden
#@ 
#@ # remove records associated with removed libs from original table e.g. libchk213_mismatched_pins
#@ proc remove_records_from_table {rm_libs tbl_name} {
#@     variable lib_name2nos
#@     set where_cond ""
#@     set i 0
#@     # compose "WHERE pin_type_direction LIKE %(Physi#1)"
#@     foreach lib_name $rm_libs {
#@ 	if [regexp {^lib[0-9]+} $lib_name] { continue }
#@ 	# if phys libs, compose where clause
#@ 	if {$i > 0} { lappend where_cond "OR" }
#@ 	set where_cond [concat "pin_type_direction LIKE \'%($lib_name2nos($lib_name))%\' "]
#@ 	incr i
#@     }
#@     if {$i > 0} {			# if phys lib removed
#@ 	db3 eval "DELETE FROM $tbl_name WHERE $where_cond"
#@ 	if {[db3 eval "SELECT COUNT(*) FROM $tbl_name"] == 0} {# remove empty table
#@ 	    db3 eval "drop table if exists $tbl_name"
#@ 	}
#@     }
#@ }
#@ define_proc_attributes remove_records_from_table -hidden
#@  
#@ # compose where clause to skip records where lib_name = libi, for all tables
#@ proc remove_lib_where {exclude_cols} {
#@     variable lib_no2names0
#@     variable db_removed
#@     variable frame_removed
#@     set db_removed 0
#@     set frame_removed 0
#@ 
#@     set where_cond "where"
#@     set i 0
#@     foreach lib_no $exclude_cols {
#@ 	if {$i > 0} {
#@ 	    lappend where_cond "and"
#@ 	}
#@ 	if {[regexp {^lib[0-9]+} $lib_no] && [info exists lib_no2names0($lib_no)]} { ;# e.g. $lib_no is lib1
#@ 	    lappend where_cond "lib_name!='$lib_no2names0($lib_no)'" 
#@ 	    set db_removed 1
#@ 	} else {
#@ 	    lappend where_cond "lib_name!='$lib_no'";# physical lib name
#@ 	    set frame_removed 1
#@ 	}
#@ 	incr i
#@     }
#@     return $where_cond
#@ }
#@ define_proc_attributes remove_lib_where -hidden
#@ 
#@ # compose where clause to skip records with consistent values: where lib2!=lib1 or lib3!=lib1
#@ proc neq_val_where {col_names exclude_cols} {
#@     set where_cond ""
#@     if {[llength $exclude_cols] > 0 && [regexp {,lib[0-9]+} $col_names] >= 0} {
#@     set col_name_lst [split $col_names ,]
#@     set where_cond "where"
#@     set lib_no 0
#@     foreach col_name $col_name_lst {
#@ 	if {[regexp {^lib[0-9]+} $col_name]} { ;# lib1, lib2, ...
#@ 	    if {$lib_no == 0} {
#@ 		set lib1 $col_name
#@ 	    } elseif {$lib_no > 1} {
#@ 		lappend where_cond "or"
#@ 		lappend where_cond "$col_name!=$lib1"
#@ 	    } else {
#@ 		lappend where_cond "$col_name!=$lib1"
#@ 	    }
#@ 	    incr lib_no
#@ 	}
#@     }
#@     if {$lib_no <= 1} {
#@ 	set where_cond ""
#@     }
#@   }
#@   return $where_cond
#@ }
#@ define_proc_attributes neq_val_where -hidden
#@ 
#@ # compose where clause for consistent values: where lib2=lib1 and lib3=lib1
#@ proc eq_val_where {col_names exclude_cols {value ""}} {
#@     set where_cond ""
#@     if {[llength $exclude_cols] > 0 && [regexp {,lib[0-9]+} $col_names] >= 0} {
#@     set col_name_lst [split $col_names ,]
#@     set where_cond "where"
#@     set lib_no 0
#@     foreach col_name $col_name_lst {
#@ 	if {[regexp {^lib[0-9]+} $col_name]} { ;# lib1, lib2, ...
#@ 	    if {$lib_no == 0} {
#@ 		set lib1 $col_name
#@ 	    } elseif {$lib_no > 1} {
#@ 		lappend where_cond "and"
#@ 		lappend where_cond "$col_name=$lib1"
#@ 	    } else {
#@ 		lappend where_cond "$col_name=$lib1"
#@ 	    }
#@ 	    incr lib_no
#@ 	}
#@     }	
#@     if {$value != ""} {
#@ 	lappend where_cond "and"
#@ 	lappend where_cond "$lib1=$value"
#@     }
#@     if {$lib_no <= 1} {
#@ 	set where_cond ""
#@     }
#@   }
#@   return $where_cond
#@ }
#@ define_proc_attributes eq_val_where -hidden
#@ 
#@ # compose join on condition: main.$tbl_name.$col_name=inc_db3.$tbl_name.$col_name
#@ proc join_on_cond {tbl_name col_names} {
#@     set col_name_lst [split $col_names ,]
#@     #get all columns other than lib1, lib2, ...
#@     set on_cond ""
#@     foreach col_name $col_name_lst {
#@ 	if {[regexp {^lib[0-9]+} $col_name] == 0} { ;# if a key column name other than lib1, ...
#@ 	    #lappend col_name_lst1 $col_name
#@ 	    if {[llength $on_cond] > 0} {
#@ 		lappend on_cond "AND"
#@ 	    }
#@ 	    lappend on_cond "main.$tbl_name.$col_name=inc_db3.$tbl_name.$col_name"
#@ 	}
#@     }
#@     return $on_cond
#@ }
#@ define_proc_attributes join_on_cond -hidden
#@ 
#@ # get max lib number from tbl_struct returned from [pragma table_info($tbl_name)]
#@ proc get_max_lib_no {tbl_struct} {
#@     set cols [lindex [print_column_names_for_table "" $tbl_struct "" ","] 1]
#@     set max_lib_no [string range $cols [string last lib $cols]+3 [string length $cols]-1]
#@     return $max_lib_no
#@ }
#@ define_proc_attributes get_max_lib_no -hidden
#@ 
#@ # get max Logic#/Physi# number from libchk201_library_list
#@ # lib_type = 'Logic#' or 'Physi#'
#@ proc get_max_lib_no_libchk201 {lib_type db3} {
#@     set lib_nums [$db3 eval "select lib_no from 'libchk201_library_list' where lib_no like '${lib_type}%'"]
#@     set max_lib_no [lindex $lib_nums [expr [llength $lib_nums]-1]]
#@     return [string range $max_lib_no 6 end];# max lib_no
#@ }
#@ define_proc_attributes get_max_lib_no_libchk201 -hidden
#@ 
#@ # prefix inc_db3.$tbl_name to each column names
#@ proc populate_column_list {col_names prefix} {
#@     set col_name_lst [split $col_names ,]
#@     #get all columns other than lib1, lib2, ...
#@     set key_cols ""
#@     foreach col_name $col_name_lst {
#@ 	if {$col_name != ""} { ;# if a valid column name
#@ 	    lappend key_cols "$prefix.$col_name,"
#@ 	}
#@     }
#@     return $key_cols
#@ }
#@ define_proc_attributes populate_column_list -hidden
#@ 
#@ # compose table names, prefix = main.$tbl_name or inc_db3.$tbl_name
#@ proc populate_lib_number_list {max_lib_no max_lib_no2 prefix} {
#@     variable lib_name2nos
#@     variable lib_no2names
#@     set lib_nos ""
#@     set lib_name ""
#@     set ndx $max_lib_no
#@     for {set i 2} {$i <= $max_lib_no2} {incr i} {
#@       lappend lib_nos $prefix.lib$i
#@       if {[string range $prefix 0 6] == "inc_db3"} { # if attach, i.e. inc_db3
#@ 	# get new lib index for libs in db3inc: $max_lib_no+1,2,... for newly added and mapped lib index in db3 via lib_name
#@ 	if [info exists lib_no2names(lib$i)] {
#@ 	    set lib_name $lib_no2names(lib$i)
#@ 	}
#@ 	if {$lib_name != "" && [info exists lib_name2nos($lib_name)]} {# if same lib is found in db3, replace it by new one
#@ 	  set lib_no $lib_name2nos($lib_name)
#@ 	} else {
#@ 	  incr ndx
#@ 	  set lib_no lib$ndx
#@ 	}
#@ 	lappend lib_nos "as"
#@ 	lappend lib_nos $lib_no
#@       }
#@       if {$i < $max_lib_no2} {
#@ 	set lib_nos [concat $lib_nos,]
#@       }
#@     }
#@     return $lib_nos
#@ }
#@ define_proc_attributes populate_lib_number_list -hidden
#@ 
#@ # get map of lib numbers from incr to original LIBCHK-201 for the replaced libraries
#@ proc map_replaced_lib_numbers {max_lib_no2} {
#@     array set arr ""
#@     variable lib_name2nos;		# from db3
#@     variable lib_no2names;		# from inc_db3
#@     variable removed_dbs
#@     set lib_name ""
#@     for {set i 2} {$i <= $max_lib_no2} {incr i} {
#@ 	if [info exists lib_no2names(lib$i)] {
#@ 	    set lib_name $lib_no2names(lib$i)
#@ 	    # if same lib is found in both db3 and -remove_libs, replace it by new one
#@ 	    if {[info exists lib_name2nos($lib_name)] && [info exists removed_dbs] && [lsearch $removed_dbs $lib_name2nos($lib_name)] >= 0} {
#@ 		set lib_no [string range $lib_name2nos($lib_name) 3 end];# strip out prefix lib to extract the number, e.g. lib2
#@ 		set arr($i) $lib_no
#@ 	    }
#@ 	}
#@     }
#@     return [array get arr]
#@ }
#@ define_proc_attributes map_replaced_lib_numbers -hidden
#@ 
#@ # compose set where string e.g. "SET lib2 = lib1, lib3 = lib1 WHERE lib2 is null" for UPDATE $tbl_name
#@ proc update_set_where {max_lib_no} {
#@     set set_values ""
#@     set where_cond ""
#@     for {set i 2} {$i <= $max_lib_no} {incr i} {
#@       lappend set_values "lib$i=lib1"
#@ 	# lib$ IS NULL
#@       lappend where_cond "lib$i"
#@       lappend where_cond "IS"
#@       lappend where_cond "NULL"
#@       if {$i < $max_lib_no} {
#@ 	append set_values ,
#@ 	lappend where_cond "AND"
#@       }
#@     }
#@     return [concat $set_values "WHERE" $where_cond]
#@ }
#@ define_proc_attributes update_set_where -hidden
#@ 
#@ # Get extra db cells from incr LIBCHK-310 $tbl_name (those missing on lib1)
#@ # Scenario 2.1: check_library -logic_vs_physical with dbs added 
#@ # Ex: extra_cells = "FOOT2X16_HVT FOOT2X2_HVT", llength = 0 if empty
#@ proc get_extra_db_cells_dbs_added {tbl_name} {
#@     variable extra_db_cells_dbs_added
#@     set extra_db_cells_dbs_added ""
#@     set tbl_exist [db3inc eval "pragma table_info($tbl_name)"]
#@     if [llength $tbl_exist] {
#@ 	set extra_db_cells_dbs_added [db3inc eval " SELECT cell_name from $tbl_name WHERE lib1='missing' "]
#@     }
#@     return $extra_db_cells_dbs_added
#@ }
#@ define_proc_attributes get_extra_db_cells_dbs_added -hidden
#@ 
#@ # Get extra cells from updated LIBCHK-310 (those missing cells in all non-removed dbs)
#@ # Scenario 2.2: check_library -logic_vs_physical with dbs removed
#@ proc get_extra_db_cells_dbs_removed {tbl_name cols rm_libs} {
#@     variable extra_db_cells_dbs_removed
#@     set where_eq_cond [eq_val_where $cols $rm_libs "missing"]
#@     set extra_db_cells_dbs_removed [db3 eval " SELECT cell_name FROM $tbl_name $where_eq_cond "] 
#@     return $extra_db_cells_dbs_removed
#@ }
#@ define_proc_attributes get_extra_db_cells_dbs_removed -hidden
#@ 
#@ # Get extra cells in dbs: from old LIBCHK-211
#@ # Get extra cells in frame: from old LIBCHK-210
#@ # Get cells in new frame from incr LIBCHK-210 with _rpt_phys = 1
#@ # Scenario 3.1: check_library -logic_vs_physical with frame added 
#@ # Scenario 3.2: check_library -logic_vs_physical with frame removed 
#@ proc get_extra_cells {tbl_name} {
#@     set extra_cells ""
#@     set tbl_exist [db3 eval "pragma table_info($tbl_name)"]
#@     if [llength $tbl_exist] {
#@ 	set extra_cells [db3 eval " SELECT cell_name FROM $tbl_name "]
#@     }
#@     return $extra_cells
#@ }
#@ define_proc_attributes get_extra_cells -hidden
#@ 
#@ # Get added, removed or replaced phys/logic lib names by comparing original and incr LIBCHK-201 tables
#@ # lib_type = 'Logic#' or 'Physi#', update_type = 1 if added, -1 if removed, or 2 if replaced
#@ # replaced dbs include lib1 that is the reference for incr check
#@ # return list of updated lib names
#@ proc get_updated_libs {lib_type update_type} {
#@     set lib_names0 [db3    eval "select lib_name from libchk201_library_list where lib_no like '${lib_type}%'"]
#@     set lib_names2 [db3inc eval "select lib_name from libchk201_library_list where lib_no like '${lib_type}%'"]
#@ 
#@     set lib_names "" ;# updated lib name list
#@     if {$update_type == -1} {
#@       # find lib name in db3 from db3inc
#@       foreach lib_name $lib_names0 {
#@ 	set lib_exist [lsearch $lib_names2 $lib_name]
#@ 	# removed
#@ 	if {$lib_exist < 0} {
#@ 	    lappend lib_names $lib_name
#@ 	}
#@       }
#@     } else {
#@       # find lib name in db3inc from db3
#@       foreach lib_name $lib_names2 {
#@ 	set lib_exist [lsearch $lib_names0 $lib_name]
#@ 	# added or replaced
#@ 	if {($update_type == 1 && $lib_exist < 0) || ($update_type == 2 && $lib_exist >= 0)} {
#@ 	    lappend lib_names $lib_name
#@ 	}
#@       }
#@     }
#@ 
#@     return $lib_names
#@ }
#@ define_proc_attributes get_updated_libs -hidden
#@ 
#@ # Get removed phys/logic lib names from -remove_lib option
#@ # lib_type = 'Logic#' or 'Physi#'
#@ # return list of updated lib names
#@ proc get_removed_libs {lib_type rm_libs} {
#@     set lib_names "" ;# removed lib name list
#@     foreach one_lib $rm_libs {
#@ 	if {$lib_type == "Logic#" && [regexp {^lib[0-9]+} $one_lib] && [info exists lib_no2names0($one_lib)]} { ;# e.g. $one_lib is lib1
#@ 	    lappend lib_names $lib_no2names0($one_lib)
#@ 	} else {
#@ 	    lappend lib_names $one_lib
#@ 	}
#@     }
#@     return $lib_names
#@ }
#@ define_proc_attributes get_removed_libs -hidden
#@ 
#@ # after deleting records stored in new $tbl_name (libchk311, libchk321 and libchk322), the remaining records in the old table 
#@ # contain data that have consistent values across logic libs which will be used to remove associated lines from autofix0.tcl
#@ proc get_removed_records {tbl_name} {
#@     set cell_attr_removed ""
#@     variable removed_lines
#@     set removed_lines ""
#@     set num_cols 3
#@     if {$tbl_name == "libchk311_mismatched_cells_slg"} {
#@ 	set cell_attr_removed [db3 eval " SELECT cell_name, attribute FROM ${tbl_name}_old "]
#@ 	set num_cols 2
#@     } elseif {$tbl_name == "libchk321_mismatched_pins_slg"} {
#@ 	set cell_attr_removed [db3 eval " SELECT cell_name, pin_name, attribute FROM ${tbl_name}_old "]
#@     } elseif {$tbl_name == "libchk322_mismatched_pg_pins_slg"} {
#@ 	set cell_attr_removed [db3 eval " SELECT cell_name, pg_pin, attribute FROM ${tbl_name}_old "]
#@     }
#@     # Compose pattern (e.g. '/cell_name\] -name attribute') for sed to delete from autofix0.tcl
#@     set sz [llength $cell_attr_removed]
#@     for {set i 0} {$i < $sz} {incr i $num_cols} {
#@ 	set cell1 [lindex $cell_attr_removed $i]   
#@ 	set attr [lindex $cell_attr_removed [expr $i+$num_cols-1]]   
#@ 	if {$num_cols == 2} {		# libchk311_mismatched_cells_slg
#@ 	    set cell_ptn "\\/$cell1\] -name $attr"
#@ 	} elseif {$tbl_name == "libchk321_mismatched_pins_slg"} {
#@ 	    set pin1 [lindex $cell_attr_removed [expr $i+1]];#    pin
#@ 	    set cell_ptn "\\/$cell1\\/$pin1\] -name $attr"
#@ 	} else {			# libchk322_mismatched_pg_pins_slg
#@ 	    # non-existent for now
#@ 	    set pin1 [lindex $cell_attr_removed [expr $i+1]];#    pg_pin
#@ 	    set cell_ptn "\\/$cell1\] -filter name==$pin1"
#@ 	    set pg_attr "pg_pin $attr";	# set_attribute $pg_pin %s %s
#@ 	}
#@ 	lappend removed_lines $cell_ptn
#@ 	if {$tbl_name == "libchk322_mismatched_pg_pins_slg"} {
#@ 	    lappend removed_lines $pg_attr
#@ 	}
#@     }
#@ 
#@     return $removed_lines
#@ }
#@ define_proc_attributes get_removed_records -hidden
#@ 
#@ # if $tbl_name exists in db3, return $tbl_exist not empty
#@ proc table_exists {sql_file tbl_name} {
#@     global flib_sql_list
#@     sqlite3 db3 $sql_file
#@     set tbl_exist [db3 eval "pragma table_info($tbl_name)"]
#@     if [llength $tbl_exist] {
#@ 	set flib_sql_list $tbl_exist
#@     } else {
#@ 	set flib_sql_list ""
#@     }
#@     db3 close
#@     return $tbl_exist
#@ }
#@ define_proc_attributes table_exists -hidden
#@ 
#@ # List operations
#@ # lista*listb
#@ proc list_intersect { lista listb } {
#@     set result {}
#@     foreach elem $listb {
#@ 	if { [lsearch -exact $lista $elem] != -1 } {
#@             lappend result $elem
#@ 	}
#@     }
#@     return $result
#@ }
#@ define_proc_attributes list_intersect -hidden
#@ 
#@ # lista-listb
#@ proc list_exclude { lista listb } {
#@     set result {}
#@     foreach elem $lista {
#@ 	if { [lsearch -exact $listb $elem] == -1 } {
#@             lappend result $elem
#@ 	}
#@     }
#@     return $result
#@ }
#@ define_proc_attributes list_exclude -hidden
#@ 
#@ # update autofix.tcl 
#@ # Scenario 1.1(add corner dbs): append set_attribute lines from autofix1.tcl into autofix0.tcl
#@ # Scenario 2.1(add corner dbs): concat missing_cells, if any, with extra_db_cells_dbs_added for create_dummy_physical_cell in autofix1.tcl and merge into autofix0.tcl
#@ #                               append set_attribute lines for the new extra cells into autofix0.tcl 
#@ # Scenario 3.1(add frame): extra cells in dbs: Update autofix0.tcl in $missing_cells for create_dummy_physical_cell and $extra_cells for remove_physical_lib_cell
#@ #                          extra cells in frame: No change as no db cells are added
#@ proc update_autofix_tcl {sql_file sql_file2} {
#@     # get autofix*.tcl file names
#@     set root_name  [file rootname $sql_file]
#@     set root_name2 [file rootname $sql_file2]
#@     set tcl_name  ${root_name}.tcl;	# autofix0.tcl 
#@     set tcl_name2 ${root_name2}.tcl;	# autofix1.tcl 
#@     
#@     if ![file exists $tcl_name] {	# if there is no original autofix0.tcl generated
#@ 	return
#@     }
#@ 
#@     set extra_db_cells_vs_phys [get_extra_cells "libchk211_missing_phys_cells"];# extra db cells from old libchk211 in autofix0.tc
#@ 
#@     variable db_removed
#@     variable frame_removed
#@     variable removed_phys_libs
#@     variable removed_lines;		# from libchk311, libchk321 and libchk322
#@     variable extra_db_cells_dbs_removed;	# from LIBCHK-310
#@     
#@     if {[info exists removed_lines] && $db_removed == 1} {# if dbs removed	
#@ 	# Scenario 1.2: remove lines from autofix0.tcl matching $removed_lines from libchk311, libchk321 and libchk322
#@ 	foreach one_line $removed_lines {
#@ 	    exec sed -i "/$one_line/d" $tcl_name;# removed lines that have consistent values across dbs after db_removed
#@ 	}
#@ 	# Scenario 2.2: check_library -logic_vs_physical 
#@ 	if [info exists missing_phys_cells] {
#@ 	    # extra_db_cells_dbs_removed, missing_phys_cells
#@ 	    set updated_missing_cells [list_exclude $missing_phys_cells $extra_db_cells_dbs_removed]
#@ 	    set updated_extra_cells [list_intersect $missing_phys_cells $extra_db_cells_dbs_removed]
#@ 	    # edit autofix0.tcl in-place
#@ 	    exec sed -i 's/set missing_cells \".*\"/set missing_cells \"$updated_missing_cells\"/' $tcl_name
#@ 	    exec sed -i 's/set extra_cells \".*\"/set extra_cells \"$updated_extra_cells\"/' $tcl_name
#@ 	}
#@     }
#@ 
#@     if {[info exists frame_removed] && $frame_removed == 1} {# if frame removed	
#@ 	# Scenario 3.2, need re-xcheck if LIBCHK-210 or LIBCHK-211 exists.
#@ 	# else
#@ 	# removed_phys_libs
#@ 	set line_nums "";		# line number range to delete
#@ 	set line1 [exec grep -n "Auto fix script for library" $tcl_name];# get physical lib name with line number
#@ 	regsub -all "\# Auto fix script for library " $line1 "" line1
#@ 	set linenum_to_libname [split $line1 :\n]
#@ 	set num_libs [llength $linenum_to_libname]
#@ 	for {set i 0} {$i < $num_libs} {incr i 2} {
#@ 	    set libname [lindex $linenum_to_libname [expr $i+1]]
#@ 	    if { [lsearch -exact $removed_phys_libs $libname] != -1 } {# if libname is in removed list
#@ 		set line_num [lindex $linenum_to_libname $i]
#@ 		lappend line_nums $line_num
#@ 		set i2 [expr $i+2]
#@ 		if {$i2 < $num_libs} {
#@ 		    set line_num2 [lindex $linenum_to_libname $i2]
#@ 		    incr line_num2 -1
#@ 		    lappend line_nums $line_num2
#@ 		}
#@ 	    }
#@ 	}				
#@ 	# delete lines associated with the physical lib removed
#@ 	set num_libs_removed [llength $line_nums]
#@ 	for {set i 0} {$i < $num_libs_removed} {incr i 2} {
#@ 	    set line_num1 [lindex $line_nums $i]
#@ 	    set line_num2 [lindex $line_nums [expr $i+1]]
#@ 	    if {[expr $i+1] < $num_libs_removed} {
#@ 		exec sed -i "$line_num1,${line_num2}d" $tcl_name
#@ 	    } else {
#@ 		exec sed -i "$line_num1,\$d" $tcl_name
#@ 	    }
#@ 	}
#@ 	if {[file size $tcl_name] == 0} {
#@ 	    exec rm -rf $tcl_name;	# remove $tcl_name if empty
#@ 	}
#@     }
#@ 
#@     if ![file exists $tcl_name2] {	# if there is no autofix1.tcl generated
#@ 	return
#@     }
#@ 
#@     # get extra cells
#@     set extra_db_cells_exist 0
#@     set extra_db_cells_dbs_added [get_extra_db_cells_dbs_added "libchk310_missing_cells_slg"]
#@     if [llength $extra_db_cells_dbs_added] {
#@ 	set extra_db_cells_exist 1 
#@     }
#@     set file_id [open $tcl_name a+];	# open autofix0.tcl and append lines from autofix1.tcl
#@     # update tcl_name (autofix0.tcl)
#@     # scenario 3.1
#@     if [llength $extra_db_cells_vs_phys] {
#@ 	set missing_cells0 [exec grep missing_cells $tcl_name]
#@ 	set extra_cells0 [exec grep extra_cells $tcl_name]
#@ 	# edit autofix0.tcl in-place
#@ 	exec sed -i 's/$missing_cells0/$flib_missing_cells/' $tcl_name
#@ 	exec sed -i 's/$extra_cells0/$flib_extra_cells/' $tcl_name
#@     }
#@ 
#@     # read and process tcl_name2 and merge output to tcl_name
#@     set file_id2 [open $tcl_name2 r]
#@     set blk_tag 0;				# identifier for autofix block
#@     while {[gets $file_id2 line] >= 0} {
#@ 	if {[regexp {^\# Cell attributes to be corrected} $line] >= 0} {
#@ 	    set blk_tag 1
#@ 	} elseif {[regexp {^\# Pin attributes to be corrected} $line] >= 0} {
#@ 	    set blk_tag 1
#@ 	} elseif {[regexp {^\# PG pin attributes to be corrected} $line] >= 0} {
#@ 	    set blk_tag 1
#@ 	} elseif {[regexp {^\# Cells to be removed from physical libraries} $line] >= 0} {# xcheck starts
#@ 	    set blk_tag 2
#@ 	} elseif {[regexp {^\# Cells to be removed from logic libraries} $line] >= 0} {
#@ 	    set blk_tag 3
#@ 	} elseif {[regexp {^\# Cells to be added in physical libraries} $line] >= 0} {# missing_cells; create_dummy_physical_cell
#@ 	    set blk_tag 4
#@ #	} elseif {[regexp {^\# Cells to be added in logic libraries} $line] >= 0} {
#@ #	    set blk_tag 5
#@ 	} elseif {[regexp {^\# PG/pins to be corrected by DB in .+} $line] >= 0} {
#@ 	    set blk_tag 6
#@ 	} elseif {[regexp {^\# PG/pins to be corrected by frame in .+} $line] >= 0} {
#@ 	    set blk_tag 7
#@ 	} elseif {[regexp {^\# Diode cells to be corrected in physical libraries} $line] >= 0} {# $diode_cells
#@ 	    set blk_tag 8
#@ 	} elseif {[regexp {^\# Diode pins to be corrected in physical libraries} $line] >= 0} {
#@ 	    set blk_tag 8
#@ 	} elseif {[regexp {^\# Pins to be added in physical librariess} $line] >= 0} {
#@ 	    set blk_tag 9
#@ 	} elseif {[regexp {^\# Pins to be added in logic librariess} $line] >= 0} {
#@ 	    set blk_tag 10
#@ 	} elseif {[regexp {^\# Pins to be removed from physical librariess} $line] >= 0} {
#@ 	    set blk_tag 11
#@ 	} elseif {[regexp {^\# Pins to be removed from logic librariess} $line] >= 0} {
#@ 	    set blk_tag 12
#@ 	}
#@ 				
#@ 	# append the related block to autofix0.tcl
#@ 	switch -exact $blk_tag {
#@ 	    1 {	# logic lib
#@ 		# append set_attribute lines from autofix1.tcl into autofix0.tcl
#@ 		if {$extra_db_cells_exist == 1} {
#@ 		    puts $file_id "$line"
#@ 		}
#@ 	    }
#@ 	    4 { # missing_cells+=extra_db_cells_dbs_added; create_dummy_physical_cell
#@ 		if {$extra_db_cells_exist == 1} {
#@ 		    if {[regexp {^set missing_cells .*} $line] >= 0} {
#@ 			#set extra_db_cells_vs_phys [get_extra_cells "libchk211_missing_phys_cells"]
#@ 			if [llength $extra_db_cells_vs_phys] {# if autofix0.tcl has missing_cells, concat new extra cells 
#@ 			    puts $file_id "concat \$missing_cells $extra_db_cells_dbs_added"
#@ 			} else {
#@ 			    puts $file_id "set missing_cells \"$extra_db_cells_dbs_added\""
#@ 			}
#@ 		    }
#@ 		}
#@ 	    }
#@ 	    6 { # PG/pins to be corrected by DB
#@ 		if {$extra_db_cells_exist == 1} {
#@ 		    # if $cell1 is in $extra_db_cells_dbs_added, append it in autofix0.tcl
#@ 		    set slash1 [string first '/' $line]
#@ 		    set slash2 [string last '/' $line]
#@ 		    incr slash2 -1
#@ 		    #set_attribute [get_physical_lib_pins */cell1/VDD] port_type power
#@ 		    set cell1 [string range $line $slash1 $slash2]
#@ 		    if { [lsearch -exact $extra_db_cells_dbs_added $cell1] >= 0 } {
#@ 			puts $file_id "$line"
#@ 		    }
#@ 		}
#@ 	    }
#@ 	    8 { # Diode cells 
#@ 		if {$extra_db_cells_exist == 1} {
#@ 		  puts $file_id "$line"
#@ 		  #if {[regexp {^set diode_cells .*} $line] >= 0} {# set diode_cells "diode cell name list"
#@ 		      #puts $file_id {concat $diode_cells $extra_db_cells_dbs_added};# concat diode cells from $extra_db_cells_dbs_added
#@ 		  #}
#@ 		}
#@ 	    }
#@ 	    default { }
#@ 	}
#@     }
#@ 
#@     close $file_id
#@ 
#@ }
#@ define_proc_attributes update_autofix_tcl -hidden
#@ }
#@ # -- End source /usr/cad/synopsys/lc/2022.12-sp6/auxx/lc/report_check_library_records.tcl

#@ source $synopsys_root/auxx/lc/set_attribute.tcl
#@ # -- Starting source /usr/cad/synopsys/lc/2022.12-sp6/auxx/lc/set_attribute.tcl

#@ proc set_attribute { args } {
#@   parse_proc_arguments -args $args ra
#@   set option_error 0
#@ 
#@   if {[info exists ra(library_name)] && 
#@       ![string length $ra(library_name)] } {
#@     if { [info exist ::env(LCLM_DBG)] } {
#@       echo "DBG: empty library_name"
#@     }
#@     return; 
#@   }
#@   if {[info exists ra(library_name)] && [info exists ra(-objects)]} {
#@     echo "Error: Cannot specify library_object with -objects. (CMD-001)"
#@     set option_error 1
#@   }
#@   if {[info exists ra(attribute_name)] && [info exists ra(-name)]} {
#@     echo "Error: Cannot specify attribute_name with -name. (CMD-001)"
#@     set option_error 1
#@   }
#@   if {[info exists ra(attribute_value)] && [info exists ra(-value)]} {
#@     echo "Error: Cannot specify attribute_value with -value. (CMD-001)"
#@     set option_error 1
#@   }
#@   if { $option_error } {
#@     return
#@   }
#@   if {![info exists ra(library_name)] && ![info exists ra(-objects)]} {
#@     echo "Error: Must specify one of these options: library_object or -objects. (CMD-004)"
#@     set option_error 1
#@   }
#@   if {![info exists ra(attribute_name)] && ![info exists ra(-name)]} {
#@     echo "Error: Must specify one of these options: attribute_name or -name. (CMD-004)"
#@     set option_error 1
#@   }
#@   if {![info exists ra(attribute_value)] && ![info exists ra(-value)]} {
#@     echo "Error: Must specify one of these options: attribute_value or -value. (CMD-004)"
#@     set option_error 1
#@   }
#@   if { $option_error } {
#@     return
#@   }
#@   if { [info exists ra(-objects)]} {
#@     set library_name $ra(-objects)
#@   } else {
#@     set library_name $ra(library_name)
#@   }
#@   if { [info exists ra(-name)]} {
#@     set attribute_name $ra(-name)
#@   } else {
#@     set attribute_name $ra(attribute_name)
#@   }
#@    
#@   if { [info exists ra(-value)]} {
#@     set attribute_value $ra(-value)
#@   } else {
#@     set attribute_value $ra(attribute_value)
#@   }
#@  
#@   if { [info exists ra(-class)]} {
#@     set class_value $ra(-class)
#@   } else {
#@     set class_value ""
#@   }
#@  
#@   if { $class_value != "" } {
#@     if { [string match "fusion*" $class_value ] == 1 } {
#@       set class_name $class_value
#@     } else {
#@       set class_name [get_lib_attribute $library_name "c_name" -quiet -class $class_value]
#@     }
#@   } else {
#@     set class_name [get_lib_attribute $library_name "c_name" -quiet]
#@   }
#@ 
#@   if { [string match "logical*" $class_name ] == 1 } {
#@     # skip physical attribute
#@     if [string match "pattern_must_join" $attribute_name ] {
#@       return
#@     }
#@     set cmd set_logical_attribute
#@   } elseif { [string match "fusion*" $class_name ] == 1 } {
#@     set cmd set_fusion_attribute
#@   } else {
#@     set cmd set_physical_attribute
#@   }
#@   lappend cmd $library_name $attribute_name $attribute_value
#@   if { $class_value != "" } {
#@     lappend cmd "-class" $class_value
#@   }
#@   return [eval $cmd]
#@ }
#@ 
#@ define_proc_attributes set_attribute \
#@     -info "set library object attribute" \
#@     -define_args {
#@       {library_name "library" library_name list optional}
#@       {attribute_name "attribute name" attribute_name string optional}
#@       {attribute_value "attribute value" attribute_value string optional}
#@       {-class           "class name"     class string optional}
#@       {-name           "attr name"       name  string optional}
#@       {-value          "attr value"      value string optional}
#@       {-objects          "attr value"    object string optional}
#@       {-quiet "Suppress all messages"  "" boolean optional}
#@ }
#@ 
#@ alias set_lib_attribute set_attribute
#@ 
#@ 
#@ proc get_attribute { args } {
#@   parse_proc_arguments -args $args ra
#@   set option_error 0
#@ 
#@   if {[info exists ra(library_name)] && 
#@       ![string length $ra(library_name)] } {
#@     if { [info exist ::env(LCLM_DBG)] } {
#@       echo "DBG: empty library_name"
#@     }
#@     return; 
#@   }
#@   if {[info exists ra(object_list)] && [info exists ra(-objects)]} {
#@     echo "Error: Cannot specify object_list with -objects. (CMD-001)"
#@     set option_error 1
#@   }
#@   if {[info exists ra(attribute_name)] && [info exists ra(-name)]} {
#@     echo "Error: Cannot specify attribute_name with -name. (CMD-001)"
#@     set option_error 1
#@   }
#@   if { $option_error } {
#@     return -code error
#@   }
#@   if {![info exists ra(object_list)] && ![info exists ra(-objects)]} {
#@     echo "Error: Must specify one of these options: object_list or -objects. (CMD-004)"
#@     set option_error 1
#@   }
#@   if {![info exists ra(attribute_name)] && ![info exists ra(-name)]} {
#@     echo "Error: Must specify one of these options: attribute_name or -name. (CMD-004)"
#@     set option_error 1
#@   }
#@   if { $option_error } {
#@     return -code error
#@   }
#@   if { [info exists ra(-objects)]} {
#@     set library_name $ra(-objects)
#@   } else {
#@     set library_name $ra(object_list)
#@   }
#@   if { [info exists ra(-name)]} {
#@     set attribute_name $ra(-name)
#@   } else {
#@     set attribute_name $ra(attribute_name)
#@   }
#@    
#@   if { [info exists ra(-class)]} {
#@     set class_value $ra(-class)
#@   } else {
#@     set class_value ""
#@   }
#@  
#@   if { [info exists ra(-value_list)]} {
#@     set has_value_list 1
#@   } else {
#@     set has_value_list 0
#@   }
#@   if { [info exists ra(-line_number)]} {
#@     set has_line_number 1
#@   } else {
#@     set has_line_number 0
#@   }
#@   if { [info exists ra(-user_defined_data)]} {
#@     set has_user_defined_data 1
#@   } else {
#@     set has_user_defined_data 0
#@   }
#@   if { [info exists ra(-ctl)]} {
#@     set has_ctl 1
#@   } else {
#@     set has_ctl 0
#@   }
#@   if { [info exists ra(-quiet)]} {
#@     set has_quiet 1
#@   } else {
#@     set has_quiet 0
#@   }
#@ 
#@   if { $class_value != "" } {
#@     if { [string match "fusion*" $class_value ] == 1 } {
#@       set class_name $class_value
#@     } else {
#@       set class_name [get_lib_attribute $library_name "c_name" -quiet -class $class_value]
#@     }
#@   } else {
#@     set class_name [get_lib_attribute $library_name "c_name" -quiet]
#@   }
#@ 
#@   if { [string match "fusion*" $class_name ] == 1 } {
#@     set cmd __get_attribute
#@     if { $has_line_number } {
#@       echo "Error: -line_number not supported for $class_name object. Ignored."
#@     }
#@     if { $has_user_defined_data } {
#@       echo "Error: -user_defined_data not supported for $class_name object. Ignored."
#@     }
#@     if { $has_ctl } {
#@       echo "Error: -ctl not supported for $class_name object. Ignored."
#@     }
#@     if { $has_value_list } {
#@       lappend cmd "-value_list"
#@     }
#@   } else {
#@     set cmd get_lib_attribute
#@     if { $has_line_number } {
#@       lappend cmd "-line_number"
#@     }
#@     if { $has_user_defined_data } {
#@       lappend cmd "-user_defined_data"
#@     }
#@     if { $has_ctl } {
#@       lappend cmd "-ctl"
#@     }
#@     if { $has_value_list } {
#@       echo "Error: -value_list not supported for $class_name object. Ignored."
#@     }
#@   }
#@   lappend cmd $library_name $attribute_name
#@   if { $class_value != "" } {
#@     lappend cmd "-class" $class_value
#@   }
#@   if { $has_quiet } {
#@     lappend cmd "-quiet"
#@   }
#@   return [eval $cmd]
#@ }
#@ 
#@ define_proc_attributes get_attribute \
#@     -info "set library object attribute" \
#@     -define_args {
#@       {-class "class name" class string optional}
#@       {-line_number "returns the line number of the -of_objects" "" boolean optional}
#@       {-user_defined_data "returns user defined object" "" boolean optional}
#@       {-ctl "returns ctl attribute for cell object" "" boolean optional}
#@       {-quiet "Do not report any messages"  "" boolean optional}
#@       {-value_list "Force single object return as list" "" boolean optional}
#@       {-objects "Object(s) from which to get the attribute" object_spec list optional}
#@       {-name "Name of the attribute" attr_name  string optional}
#@       {object_list "list of library objects to get attribute" object_list list optional}
#@       {attribute_name "an attribute name of the library object" attribute_name string optional}
#@ }
#@ 
#@ # -- End source /usr/cad/synopsys/lc/2022.12-sp6/auxx/lc/set_attribute.tcl

#@ 
#@ #for read_lib -html	
#@ source ${synopsys_root}/auxx/lc/read_lib_html_msg_list.tcl
#@ # -- Starting source /usr/cad/synopsys/lc/2022.12-sp6/auxx/lc/read_lib_html_msg_list.tcl

#@ ##############################################################################
#@ # message ID and descriptions for read_lib -html
#@ # Rev01. changed LBDB-715 to LBDB-262, STAR 9001225503, jizhan, Aug 17
#@ # Rev02. removed LBDB-825, STAR 9001541784, jizhan, Aug 19
#@ ##############################################################################
#@ set read_lib_ccs_noise_msg {
#@     LBDB-262
#@     LBDB-660
#@     LBDB-706
#@     LBDB-708
#@     LBDB-709
#@     LBDB-710
#@     LBDB-711
#@     LBDB-712
#@     LBDB-713
#@     LBDB-714
#@     LBDB-716
#@     LBDB-717
#@     LBDB-718
#@     LBDB-733
#@     LBDB-734
#@     LBDB-784
#@     LBDB-824
#@     LBDB-858
#@     LBDB-898
#@     LBDB-899
#@     LBDB-908
#@     LBDB-920
#@     LBDB-935
#@     LBDB-936
#@     LBDB-937
#@     LBDB-938
#@     LBDB-939
#@ }
#@ # -- End source /usr/cad/synopsys/lc/2022.12-sp6/auxx/lc/read_lib_html_msg_list.tcl

#@ #alias list_commands help
#@ 
#@ if {  [info commands "create_physical_lib"] == "create_physical_lib" } {
#@ # create_physical_lib only exists in lc2_shell, slc_shell don't need to source those script
#@ # You can add a file named LC2_setup.tcl to auxx/LC2/tcl if you want
#@ # some extra initialization separate from the .synopsys files.
#@   lappend auto_path [file join $::synopsys_root auxx LC2 tcl]
#@     if { [file exists [file join $::synopsys_root auxx LC2 tcl LC2_setup.tcl]] } {
#@       source [file join $::synopsys_root auxx LC2 tcl LC2_setup.tcl]
#@     }
#@   if { [file exists [file join $::synopsys_root auxx LC2 tcl report_lib.tcl]] } {
#@ #for report_lib mega command
#@     source [file join $::synopsys_root auxx LC2 tcl report_lib.tcl]
#@   }
#@ 
#@   if { [file exists [file join $::synopsys_root auxx LC2 tcl lclm_get_lib.tcl]] } {
#@ #for get_lib* mega command
#@     source [file join $::synopsys_root auxx LC2 tcl lclm_get_lib.tcl]
#@   }
#@ }
#@ # Temporary fix for the LMC_HOME variable- set it to an empty string 
#@ 
#@ if { [catch {getenv LMC_HOME } __err ] != 0 } {
#@   setenv LMC_HOME ""
#@ }
#@ 
#@ #
#@ #
#@ #       Site-Specific Variables
#@ #
#@ #       These are the variables that are most commonly changed at a
#@ #       specific site, either upon installation of the Synopsys software,
#@ #       or by specific engineers in their local .synopsys_lc.setup files.
#@ #
#@ #
#@ 
#@ # from the System Variable Group 
#@ set search_path [list . ${synopsys_root}/libraries/syn]
#@ 
#@ # do we need command_log_file ?
#@ set command_log_file $sh_command_log_file
#@ 
#@ set view_command_log_file  "./view_command.log"
#@ 
#@ # from the View Variable group
#@ if { $sh_arch == "hp700" } {
#@    set text_print_command  "lp -d" 
#@ } else {
#@    set text_print_command  "lpr -Plw" 
#@ }
#@ 
#@ 
#@ #
#@ #       System Variable Group:
#@ #
#@ #       These variables are system-wide variables.
#@ #
#@ 
#@ set verbose_messages  "true"
#@ set echo_include_commands  "true"
#@ set suppress_errors  {}
#@ 
#@ # variables pertaining to VHDL library generation 
#@ set vhdllib_timing_mesg   "true"
#@ set vhdllib_timing_xgen   "false"
#@ set vhdllib_timing_checks   "true"
#@ set vhdllib_negative_constraint   "false"
#@ set vhdllib_glitch_handle   "true"
#@ set vhdllib_pulse_handle   "use_vhdllib_glitch_handle"
#@ # /*set vhdllib_architecture   {FTBM, UDSM, FTSM, FTGS, VITAL} */
#@ set vhdllib_architecture   {VITAL}
#@ set vhdllib_tb_compare   0
#@ set vhdllib_tb_x_eq_dontcare   FALSE
#@ set vhdllib_logic_system   "ieee-1164"
#@ set vhdllib_logical_name   ""
#@ 
#@ # variables pertaining to technology library processing 
#@ set read_db_lib_warnings   FALSE
#@ set read_translate_msff    TRUE
#@ set libgen_max_differences   -1
#@ 
#@ set view_on_line_doc_cmd ${synopsys_root}/sold
#@ 
#@ # Aliases for backwards compatibility or other reasons 
#@ #alias groupvar          group_variable
#@ alias free		remove_lib
#@ 
#@ # set filename for logging input file 
#@ set filename_log_file   "lc_filenames.log"  
#@ # whether to delete the filename log after the normal exits 
#@ set exit_delete_filename_log_file   "true"
#@ 
#@ #if { lc_shell_status == 0 } {
#@ #  sh echo {Fatal: System .synopsys_lc.setup file not read properly. Please re-invoke.}
#@ #  sh echo {Note that the init file .synopsy_lc.setup of lc_shell}
#@ #  sh echo {is a subset of the dc_shell init file .synopsys_dc.setup.}
#@ #  sh echo {If a non lc_shell command is encountered in the init file,}
#@ #  sh echo {an error message will be issued and the processing might terminate.}
#@ #  sh echo {Please refer to the Library Compiler reference manual for supported commands.}
#@ #  quit
#@ #}
#@ proc get_legacy_lc_search_path { } {
#@   set exec_path "invalid"
#@   if {[info exists ::env(SYNOPSYS_SYN_ROOT)] &&  [file exists $::env(SYNOPSYS_SYN_ROOT)/$::sh_arch/syn/bin/common_shell_exec] } {
#@     set exec_path $::env(SYNOPSYS_SYN_ROOT)/$::sh_arch/syn/bin/common_shell_exec
#@   }
#@   return $exec_path
#@ }
#@ 
#@ proc get_legacy_lc_synopsys_root { } {
#@   return [file dirname [file dirname [file dirname [file dirname $::legacy_lc_search_path] ] ] ] 
#@ }
#@ 
#@ 
#@ proc valias {v_orig v_alias} {
#@    uplevel 1 "upvar 0 $v_orig $v_alias"
#@ }
#@ 
#@ set legacy_lc_result_path "/tmp"
#@ set legacy_lc_replay_tcl_file "common_shell_command.tcl"
#@ set legacy_lc_search_path [get_legacy_lc_search_path]
#@ valias lc_enable_legacy_library_compiler lc_enable_common_shell_lc
#@ set compile_lib_list ""
#@ set compile_libs_pre_script_path ""
#@ set compile_libs_script_path ""
#@ set compile_libs_log_file_prefix ""
#@ set compile_libs_log_file_suffix ""
#@ set compile_libs_temp_directory ""
#@ set compile_libs_cdpl_log_directory ""
#@ set compile_libs_lic_got false
#@ set compile_libs_var_exported false
#@ set compile_libs_app_opt_exported false
#@ set compile_libs_process_label_exported false
#@ set compile_libs_set_policy_exported false
#@ 
#@ proc legacy_lc_lib2saif { args } {
#@   return [common_shell_write_lib $args]
#@ }
#@ 
#@ 
#@ proc run_legacy_lc_with_echo {tcl_file} {
#@   set chan [open "|$::legacy_lc_search_path -shell lc_shell -r [get_legacy_lc_synopsys_root] -f $tcl_file" r]
#@ # things to do: In debug mode, we want copy the whole output (beginning to end) 
#@ # to a file
#@   if {$::lc_keep_legacy_lc_temp_files} {
#@       set log [open $::legacy_lc_result_path/$::legacy_lc_log_path/libra.log w]
#@   }
#@   set echo 0
#@   set ret 0
#@   set firstLine true
#@   while {[gets $chan line] >= 0} {
#@       if {$::lc_keep_legacy_lc_temp_files} { puts $log $line }
#@       if {[string equal -length 7 $line "##@@@##"]} {
#@ 	  set echo [expr ! $echo]
#@ 	  continue;
#@       }
#@       if {$echo} { 
#@         if { $firstLine } {
#@           set firstLine false
#@           continue;
#@         } else { 
#@           if {$line == "1"} {
#@             set ret  1
#@           } elseif {$line == "0"} {
#@             set ret 0
#@           } else {
#@             puts $line 
#@           }
#@         }
#@       }
#@   }
#@   close $chan
#@   if {$::lc_keep_legacy_lc_temp_files} {
#@       close $log
#@   }
#@   return $ret;
#@ }
#@ 
#@ proc common_shell_read_lib {args } {
#@   if { [print_no_common_shell_found $::legacy_lc_search_path] } {
#@     return 0
#@   }
#@   set_folder_var
#@   set tcl_file "$::legacy_lc_result_path/$::legacy_lc_log_path/$::legacy_lc_replay_tcl_file"
#@   set chan [open $tcl_file a]
#@   export_tcl_var $chan 
#@   gen_common_shell_read_lib_procedure $chan $args
#@   close $chan
#@   echo "Invoking common shell Library Compiler..."
#@   run_legacy_lc_with_echo $tcl_file
#@   libra_shell_read_dbs
#@   common_shell_clean_up
#@ }
#@ 
#@ proc common_shell_add_pg_pin {args } {
#@   if { [print_no_common_shell_found $::legacy_lc_search_path] } {
#@     return 0
#@   }
#@   # to use error message in synthesis root as the command is called under the hood
#@   set synopsys ""
#@   set synopsys_syn_root ""
#@   if {[info exists ::env(SYNOPSYS)]} {
#@     set synopsys $::env(SYNOPSYS)
#@   }
#@   if {[info exists ::env(SYNOPSYS_SYN_ROOT)]} {
#@     set synopsys_syn_root $::env(SYNOPSYS_SYN_ROOT)
#@   }
#@   if {[string compare "$synopsys"  "$synopsys_syn_root"] && [string compare "$synopsys_syn_root" ""]} {
#@     setenv SYNOPSYS  "$synopsys_syn_root"
#@   }
#@   set_folder_var
#@   set tcl_file "$::legacy_lc_result_path/$::legacy_lc_log_path/$::legacy_lc_replay_tcl_file"
#@   set chan [open $tcl_file a]
#@   export_tcl_var $chan 
#@   gen_common_shell_add_pg_pin_procedure $chan $args
#@   close $chan
#@   run_legacy_lc_with_echo $tcl_file
#@   common_shell_clean_up
#@   # restore SYNOPSYS enviroment after call synthesis
#@   if {[string compare "$synopsys" ""]} {
#@     setenv SYNOPSYS  "$synopsys"
#@   } else {
#@     unsetenv SYNOPSYS
#@   }
#@ }
#@ 
#@ proc common_shell_write_lib {args } {
#@   if { [print_no_common_shell_found $::legacy_lc_search_path] } {
#@     return 0
#@   }
#@   set_folder_var
#@   set tcl_file $::legacy_lc_result_path/$::legacy_lc_log_path/$::legacy_lc_replay_tcl_file
#@   set chan [open $tcl_file a]
#@   export_tcl_var $chan 
#@   libra_shell_write_db
#@   gen_common_shell_write_lib_procedure $chan $args
#@   close $chan
#@   set ret [run_legacy_lc_with_echo $tcl_file]
#@   common_shell_clean_up
#@   return $ret
#@ }
#@ 
#@ proc common_shell_update_lib {args } {
#@   if { [print_no_common_shell_found $::legacy_lc_search_path] } {
#@     return 0
#@   }
#@   set_folder_var
#@   set tcl_file "$::legacy_lc_result_path/$::legacy_lc_log_path/$::legacy_lc_replay_tcl_file"
#@   set chan [open $tcl_file a]
#@   export_tcl_var $chan 
#@   libra_shell_write_db   
#@   gen_common_shell_write_lib_procedure $chan $args
#@   close $chan
#@   run_legacy_lc_with_echo $tcl_file  
#@   libra_shell_read_dbs
#@   common_shell_clean_up
#@ }
#@ 
#@ # create the unique folder under tmp
#@ proc set_folder_var { } {
#@   set fileName [pid]
#@   set ::legacy_lc_log_path [append fileName "_" [clock microseconds]] 
#@   file delete -force $::legacy_lc_result_path/$::legacy_lc_log_path
#@   file mkdir $::legacy_lc_result_path/$::legacy_lc_log_path  
#@ }
#@ 
#@ # export all the vars
#@ proc export_tcl_var { fileName } {
#@ # 2016.03.09 Liping Zhao
#@ # Fix STAR 9001014310. 
#@ # These vars should not be exported.
#@ # 2017.02.09 Liping Zhao
#@ # Fix STAR 90001079691
#@   set filter_attrs [dict create ::errorInfo 1 ::sh_continue_on_error 1 ::sh_command_log_file 1 ::command_log_file 1 ] 
#@     foreach var [info vars ::* ] {
#@       if [array exists $var] {
#@         continue;
#@       }
#@       if [ dict exists $filter_attrs $var ] {
#@         continue;
#@       } elseif [catch { set temp [set $var] } result] {
#@         continue;
#@       }
#@       if { [set $var] != "" } {
#@         puts $fileName "catch \{ set $var \[list \[binary format H* [make_hex [set $var]]\]\] \}"
#@       }  else {
#@         puts $fileName "catch \{ set $var \"\" \}"
#@       }
#@     }
#@     puts $fileName "catch \{ set lc_cpu_allocation \[list \[binary format H* [make_hex $::lc_cpu_allocation]\]\] \}"
#@ 
#@ }
#@ 
#@ proc export_tcl_vars { fileName } {
#@   set filter_attrs [dict create ::errorInfo 1 ::sh_continue_on_error 1 ::sh_command_log_file 1 ::command_log_file 1 ] 
#@     foreach var [info vars ::* ] {
#@       if [array exists $var] {
#@         continue;
#@       }
#@       if [ dict exists $filter_attrs $var ] {
#@         continue;
#@       } elseif [catch { set temp [set $var] } result] {
#@         continue;
#@       }
#@       if { [set $var] != "" } {
#@         puts $fileName "catch \{ set $var \[list \[binary format H* [make_hex [set $var]]\]\] \}"
#@       }  else {
#@         puts $fileName "catch \{ set $var \"\" \}"
#@       }
#@     }
#@     puts $fileName "catch \{ set lc_disable_ccs_noise_extraction \[list \[binary format H* [make_hex $::lc_disable_ccs_noise_extraction]\]\] \}"
#@     puts $fileName "catch \{ set lc_read_lib_exclude_ccs \[list \[binary format H* [make_hex $::lc_read_lib_exclude_ccs]\]\] \}"
#@ 
#@ }
#@ 
#@ # export all the vars for fusion lib related procedure
#@ proc export_flib_tcl_var { fileName } {
#@ # 2016.03.09 Liping Zhao
#@ # Fix STAR 9001014310. 
#@ # These vars should not be exported.
#@ # 2017.02.09 Liping Zhao
#@ # Fix STAR 90001079691
#@ # 2021.07.27 Hongqi Yu
#@ # Use "..." instead of [list ...]
#@   set filter_attrs [dict create ::errorInfo 1 ::sh_continue_on_error 1 ::sh_command_log_file 1 ::command_log_file 1 ] 
#@   # include hidden vars
#@   foreach var [concat [info vars ::* ] [set ::lc_parameter_export_list] ] {
#@     if [array exists $var] {
#@       continue;
#@     }
#@     if [ dict exists $filter_attrs $var ] {
#@       continue;
#@     } elseif [catch { set temp [set $var] } result] {
#@       puts $fileName "#cannot set $var"
#@       continue;
#@     }
#@     if { [set $var] != "" } {
#@       puts $fileName "catch \{ set $var \"\[binary format H* [make_hex [set $var]]\]\" \}"
#@     }  else {
#@       puts $fileName "catch \{ set $var \"\" \}"
#@     }
#@   }
#@ }
#@ 
#@ # excuted by libra shell to read the dbs generated by common_shell
#@ proc libra_shell_read_dbs { } {
#@   set dbNames ""
#@   foreach var [glob -nocomplain -directory $::legacy_lc_result_path/$::legacy_lc_log_path *.db] { 
#@     append dbNames " " $var
#@     read_db $var 
#@   }
#@   set ::lc_intermediate_db_files $dbNames
#@ }
#@ 
#@ # display the log file genrated by common_shell in Libra and then remove the unique folder
#@ proc common_shell_clean_up { } {
#@   if { ! $::lc_keep_legacy_lc_temp_files } { 
#@     file delete -force $::legacy_lc_result_path/$::legacy_lc_log_path 
#@   }
#@ }
#@ 
#@ # excuted by libra shell to write out the in-memory dbs
#@ proc libra_shell_write_db { } {
#@   foreach db $::lc_intermediate_db_files {
#@     write_lib $db -o $::legacy_lc_result_path/$::legacy_lc_log_path/$db.db
#@   }
#@ }
#@ 
#@ proc gen_common_shell_read_lib_procedure { fileName args} {
#@   puts $fileName "##@@@## gen_common_shell_read_lib"
#@   puts $fileName "eval [lindex [lindex $args 0] 0]"
#@   puts $fileName "##@@@##"
#@   puts $fileName "set lc_write_view_db_file false"
#@   puts $fileName "set librs \[get_libs\]"
#@   puts $fileName "for {set i 0} {\$i < \[ sizeof \$librs \]} {incr i 1} {"
#@   puts $fileName "  set lib \[index_collection \$librs \$i]"
#@   puts $fileName "  redirect -var a \"query_object \$lib\" "
#@   puts $fileName "  if \[regexp {{(\")?(gtech)(\")?}} \$a\] { "
#@   puts $fileName "  } elseif \[regexp {{(\")?(standard.sldb)(\")?}} \$a] { "
#@   puts $fileName "  } else {"
#@   puts $fileName "    regexp {{(\")?(\[^\"\]*)(\")?}} \$a b c d e "
#@   puts $fileName "    write_lib \$d -o \$legacy_lc_result_path/\$legacy_lc_log_path/\$d.db"
#@   puts $fileName "  }"
#@   puts $fileName "}"
#@   puts $fileName "exit"
#@ }
#@ 
#@ proc gen_common_shell_write_lib_procedure { fileName args } {
#@   puts $fileName "foreach var \[glob -nocomplain -directory \$legacy_lc_result_path/\$legacy_lc_log_path *.db\] { read_db \$var }"
#@   puts $fileName "set lc_write_view_db_file false"
#@   puts $fileName "##@@@## gen_common_shell_write_lib"
#@   puts $fileName "eval [lindex [lindex $args 0] 0]"
#@   puts $fileName "##@@@##"
#@   puts $fileName "exit"
#@ }
#@ 
#@ proc gen_common_shell_add_pg_pin_procedure { fileName args } {
#@   puts $fileName "##@@@## gen_common_shell_add_pg_pin"
#@   puts $fileName "eval [lindex $args 0]"
#@   puts $fileName "##@@@##"
#@   puts $fileName "exit"
#@ }
#@ 
#@ proc gen_is_none_tech_file {} {
#@   sh touch $::nglc_result_path/$::nglc_log_path/is_non_tech_file
#@ }
#@ 
#@ proc gen_is_symbol_file {} {
#@   sh touch $::nglc_result_path/$::nglc_log_path/is_symbol_file
#@ }
#@ 
#@ proc print_no_common_shell_found {arg} {
#@   if {![file exists $arg] } {
#@     echo "Error: No common shell Library Compiler found. (LCSH-2)"
#@     return 1
#@   }
#@   return 0
#@ }
#@ 
#@ proc set_host_options args {
#@     global lc_cpu_allocation
#@     if {[string compare [lindex $args 0] "-max_cores"]} {
#@ 	puts "Must specify one of these options: -max_cores. (CMD-004)"
#@ 	return
#@     } elseif {[llength $args] != 2} {
#@ 	puts "value not specified for option '-max_cores' (CMD-008)"
#@ 	return
#@     }
#@     set val [lindex $args 1]
#@     if {[string is integer $val] && ($val > 0) && ($val <= 16) } {
#@ 	set lc_cpu_allocation [expr $val - 1]
#@     } else {
#@ 	puts "value $val for option '-max_cores' not in range (1-16). (CMD-019)"
#@     }
#@     return
#@ }
#@ 
#@ proc remove_host_options {} {
#@     global lc_cpu_allocation
#@     set lc_cpu_allocation 0
#@ }
#@ 
#@ proc report_host_options {} {
#@      global lc_cpu_allocation
#@      global sh_product_version
#@      puts "****************************************
#@ Report : host_options
#@ Version: $sh_product_version
#@ Date   : [date]
#@ ****************************************
#@ 
#@ Max_cores: [expr $lc_cpu_allocation + 1]
#@ "
#@ }
#@ 
#@ define_proc_attributes set_host_options \
#@   -info "Controls the maximum number of CPU cores that can be used for read_lib command." \
#@   -define_args {
#@     {-max_cores "number_of_cores" max_cores int required}
#@ }
#@ 
#@ define_proc_attributes remove_host_options -info "Removes -max_cores specification set by the set_host_options command."
#@ 
#@ define_proc_attributes report_host_options -info "Prints a report of multi-CPU processing options as defined by the set_host_options command."
#@ 
#@ # to call init_criteria() and pass lc/lc/check_library/logic_sig_digits.tcl
#@ set_check_library_options
#@ 
#@ #
#@ # .synopsys_nwtn.setup: Application initialization file 
#@ #
#@ 
#@ # Enable stack trace output on fatal.  Not available for all architectures.
#@ if { $sh_arch == "sparcOS5" || $sh_arch == "linux" } {
#@   set_unix_variable SYNOPSYS_TRACE ""
#@ }
#@ 
#@ 
#@ proc make_hex s { 
#@   binary scan $s H* hex
#@   return $hex 
#@ }
#@ 
#@ proc gen_compile_lib_procedure { fileName libName dbFileDir logFileDir } {
#@   set libBaseName [file rootname [file tail $libName]]
#@   set logFileName $::compile_libs_log_file_prefix$libBaseName$::compile_libs_log_file_suffix.log
#@   if {$::lc_compile_libs_skip_license_check != true} {
#@   puts $fileName "while { \$::compile_libs_lic_got != true } { "
#@   puts $fileName "  set result \[ get_license Library-Compiler \] "
#@   puts $fileName "  if { \$result >0 } { "
#@   puts $fileName "    set ::compile_libs_lic_got true "
#@   puts $fileName "    break "
#@   puts $fileName "  } "
#@   puts $fileName "  echo \"not got\" "
#@   puts $fileName "  after 30000" 
#@   puts $fileName "}" 
#@   }
#@   puts $fileName "if { \$::compile_libs_var_exported != true } {"
#@   puts $fileName "  echo \"var not exported\" "
#@   export_tcl_vars $fileName
#@   puts $fileName "  set ::compile_libs_var_exported true"
#@   puts $fileName "}"
#@   #puts $fileName "info hostname"
#@   #puts $fileName "date"
#@   if { $logFileDir == "" } {
#@     set logFileDir [pwd]
#@   }
#@   if {$::lc_cpu_allocation > 0} {
#@     puts $fileName "set_host_options -max_cores [expr $::lc_cpu_allocation + 1]"
#@     #puts $fileName "report_host_options"
#@   }
#@   puts $fileName "redirect -file $logFileDir/$logFileName { set librs \[read_lib $libName -return_lib_collection\] }"
#@   puts $fileName "for {set i 0} {\$i < \[ sizeof \$librs \]} {incr i 1} {"
#@   puts $fileName "  set lib \[index_collection \$librs \$i]"
#@   puts $fileName "  redirect -var a \"query_object \$lib\" "
#@   puts $fileName "  regexp {{(\")?(\[^\"\]*)(\")?}} \$a b c d e "
#@   if { $dbFileDir == "" } {
#@     set dbFileDir [pwd]
#@   }
#@   puts $fileName "  write_lib \$d -o $dbFileDir/\$d.db"
#@   puts $fileName "}"
#@   #puts $fileName "incr ::compile_libs_count"
#@   #puts $fileName "echo \"\[info hostname\]_compile_libs_count : \$::compile_libs_count\""
#@   puts $fileName "if { \[ sizeof_collection \$librs \] >0 } {"
#@   puts $fileName "  set sucFlag \[ open $::compile_libs_temp_directory/sucFlags/\[file tail $libName\] a \]"
#@   puts $fileName "  close \$sucFlag "
#@   puts $fileName "} else {"
#@   puts $fileName "  set failFlag \[ open $::compile_libs_temp_directory/failFlags/\[file tail $libName\] a \]"
#@   puts $fileName "  close \$failFlag "
#@   puts $fileName "}"
#@   puts $fileName "remove_lib -all"
#@   
#@ }
#@ 
#@ proc gen_create_frame_from_lef_proc { fileName } {
#@    puts $fileName "proc create_frame_from_lef { lefFiles framePath techName scaleFactor minCoverDbs postScript } {"
#@    puts $fileName "  set __cmd \[list create_physical_lib\]"
#@    puts $fileName "  set __frameTailName \[file tail \$framePath\]"
#@    puts $fileName "  set __frameTailRootName \[file rootname \$__frameTailName\]"
#@    puts $fileName "  lappend __cmd \$__frameTailRootName"
#@    puts $fileName "  if { \$techName != \"\" } {"
#@    puts $fileName "    lappend __cmd \"-technology\""
#@    puts $fileName "    lappend __cmd \$techName"
#@    puts $fileName "  }"
#@    puts $fileName "  if { \$scaleFactor != \"\" } {"
#@    puts $fileName "    lappend __cmd \"-scale_factor\""
#@    puts $fileName "    lappend __cmd \$scaleFactor"
#@    puts $fileName "  }"
#@    puts $fileName "  eval \$__cmd"
#@    puts $fileName "  set __frameCreationOptions \[get_app_option_value -name fusion_lib.create_frame_options\]"
#@    puts $fileName "  if { \$__frameCreationOptions != \"\" } {"
#@    puts $fileName "    read_lef \$lefFiles"
#@    puts $fileName "  } else {"
#@    puts $fileName "    read_lef \$lefFiles -direct_to_frame"
#@    puts $fileName "  }"
#@    puts $fileName "  if { \$minCoverDbs != \"\" } {"
#@    puts $fileName "    update_physical_properties -include_pin_attributes secondary_pg -verbose -format db -files \$minCoverDbs"
#@    puts $fileName "    if { \$__frameCreationOptions == \"\" } {"
#@    puts $fileName "      recreate_frame"
#@    puts $fileName "    }"
#@    puts $fileName "  }"
#@    puts $fileName "  if { \$__frameCreationOptions != \"\" } {"
#@    puts $fileName "    eval create_frame \$__frameCreationOptions"
#@    puts $fileName "  }"
#@    puts $fileName "  if { \$postScript != \"\" } {"
#@    puts $fileName "    source -echo -verbose \$postScript"
#@    puts $fileName "  }"
#@    puts $fileName "  write_physical_lib -force -output \$framePath"
#@    puts $fileName "}"
#@ }
#@ 
#@ proc gen_generate_frame_from_mw_proc { fileName } {
#@    puts $fileName "proc generate_frame_from_mw_wrapper { mwLibPath framePath logFileDir minCoverDbs internal useIcc } {"
#@    puts $fileName "  if { \$internal } {"
#@    puts $fileName "    set internalOpt \"-internal\""
#@    puts $fileName "  } else {"
#@    puts $fileName "    set internalOpt \"\""
#@    puts $fileName "  }"
#@    puts $fileName "  if { \$useIcc } {"
#@    puts $fileName "    set useIccOpt \"-use_icc\""
#@    puts $fileName "  } else {"
#@    puts $fileName "    set useIccOpt \"\""
#@    puts $fileName "  }"
#@    puts $fileName "  eval generate_frame_from_mw \$framePath -mw_lib \$mwLibPath -log_file_dir \$logFileDir \$internalOpt \$useIccOpt"
#@    puts $fileName "  open_physical_lib \$framePath"
#@    puts $fileName "  if { \$minCoverDbs != \"\" } {"
#@    puts $fileName "    update_physical_properties -include_pin_attributes secondary_pg -verbose -format db -files \$minCoverDbs"
#@    puts $fileName "    recreate_frame"
#@    puts $fileName "  }"
#@    puts $fileName "  write_physical_lib -force -output \$framePath"
#@    puts $fileName "}"
#@ }
#@ 
#@ proc gen_recreate_frame_proc { fileName } {
#@    puts $fileName "proc recreate_frame {} {"
#@    puts $fileName "  set __lib_cells \[get_physical_lib_cells -quiet */*/design\]"
#@    puts $fileName "  foreach_in_collection __design_view \$__lib_cells {"
#@    puts $fileName "    set __modified \[get_attribute \${__design_view} is_modified\]"
#@    puts $fileName "    if { \$__modified == \"true\" } {"
#@    puts $fileName "      set __lib_cell_name \[get_attribute \$__design_view name\]"
#@    puts $fileName "      set __config_mode \[get_attribute \$__design_view config_frame_option_mode\]"
#@    puts $fileName "      if { \$__config_mode != \"\" } {"
#@    puts $fileName "        configure_frame_options -auto_run_create_frame -mode \$__config_mode \${__lib_cell_name}"
#@    puts $fileName "      } else {"
#@    puts $fileName "        create_frame \${__lib_cell_name}"
#@    puts $fileName "      }"
#@    puts $fileName "    }"
#@    puts $fileName "  }"
#@    puts $fileName "}"
#@ }
#@ 
#@ proc gen_remove_physical_cells_proc { fileName } {
#@    puts $fileName "proc remove_physical_cells { removeCellNames } {"
#@    puts $fileName "  foreach __cell_name \$removeCellNames {"
#@    puts $fileName "    foreach __view_name { design frame layout } {"
#@    puts $fileName "      catch {"
#@    puts $fileName "        set __cells_to_remove \[ get_physical_lib_cells -quiet */\${__cell_name}/\${__view_name} \]"
#@    puts $fileName "        if { \[sizeof_collection \${__cells_to_remove} \] > 0 } {"
#@    puts $fileName "          remove_physical_lib_cells \${__cells_to_remove}"
#@    puts $fileName "        }"
#@    puts $fileName "      }"
#@    puts $fileName "    }"
#@    puts $fileName "  }"
#@    puts $fileName "}"
#@ }
#@ 
#@ proc gen_cdpl_header_procedure { fileName restoreProcessScript setPolicyScript} {
#@    puts $fileName "if { \$::compile_libs_var_exported != true } {"
#@    puts $fileName "  echo \"var not exported\" "
#@    export_flib_tcl_var $fileName
#@    puts $fileName "  set ::compile_libs_var_exported true"
#@    puts $fileName "}"
#@ 
#@    puts $fileName "if { \$::compile_libs_app_opt_exported != true } {"
#@    puts $fileName "  echo \"app options not exported\" "
#@    set appOptionScriptPath $::compile_libs_script_path/app_options.tcl
#@    if { ![file exists $appOptionScriptPath] } {
#@      write_app_options -non_default -output $appOptionScriptPath
#@    }
#@    puts $fileName "  catch \{ read_app_options $appOptionScriptPath \}"
#@    puts $fileName "  set ::compile_libs_app_opt_exported true"
#@    puts $fileName "}"
#@ 
#@    if {$restoreProcessScript != ""} {
#@      puts $fileName "if { \$::compile_libs_process_label_exported != true } {"
#@      puts $fileName "  echo \"process label setting not exported\" "
#@      puts $fileName $restoreProcessScript
#@      puts $fileName "  set ::compile_libs_process_label_exported true"
#@      puts $fileName "}"
#@    }
#@ 
#@    if {$setPolicyScript != ""} {
#@      puts $fileName "if { \$::compile_libs_set_policy_exported != true } {"
#@      puts $fileName "  echo \"early data check policy setting not exported\" "
#@      puts $fileName $setPolicyScript
#@      puts $fileName "  set ::compile_libs_set_policy_exported true"
#@      puts $fileName "}"
#@    }
#@ }
#@ 
#@ proc gen_check_status_procedure { fileName statusFile useReturn } {
#@    puts $fileName "if { \$__suc == 0 && \$__res == 1 } {"
#@    puts $fileName "  set __sucFlag \[ open $::compile_libs_temp_directory/sucFlags/$statusFile a \]"
#@    puts $fileName "  close \$__sucFlag "
#@    if { $useReturn } {
#@      puts $fileName "  return 1"
#@    } else {
#@      puts $fileName "  exit 0"
#@    }
#@    puts $fileName "} else {"
#@    puts $fileName "  set __failFlag \[ open $::compile_libs_temp_directory/failFlags/$statusFile a \]"
#@    puts $fileName "  close \$__failFlag "
#@    if { $useReturn } {
#@      puts $fileName "  return 0"
#@    } else {
#@      puts $fileName "  exit 1"
#@    }
#@    puts $fileName "}"
#@ }
#@ 
#@ proc gen_compile_flib_script { useCdpl index libPath dbNames frameNdms dbCreateFlag frameCreateFlag isForce logFilePath tclFilePath maxThreadCount verbose {removeCellNames ""} {restoreProcessScript ""} {setPolicyScript ""} } {
#@    set libPath [file normalize $libPath]
#@    set libName [file tail $libPath]
#@    set statusFile "compile_fusion_lib_${index}_${libName}"
#@ 
#@    set fileName [open $tclFilePath a]
#@    if { $useCdpl } {
#@      gen_cdpl_header_procedure $fileName $restoreProcessScript $setPolicyScript
#@    }
#@ 
#@    if { $isForce } {
#@      set isForce "-force"
#@    } else {
#@      set isForce ""
#@    }
#@    if { $dbNames!="" } {
#@      set dbNamesOpt "-dbs $dbNames"
#@    } else {
#@      set dbNamesOpt ""
#@    }
#@    if { $frameNdms!="" } {
#@      set frameNdmsOpt "-frames $frameNdms"
#@    } else {
#@      set frameNdmsOpt ""
#@    }
#@    if { !$useCdpl && $verbose } {
#@      set teeOpt "-tee"
#@    } else {
#@      set teeOpt ""
#@    }
#@ 
#@    if { $removeCellNames != "" } {
#@      gen_remove_physical_cells_proc $fileName
#@    }
#@ 
#@    set logFilePath [file normalize $logFilePath]
#@    puts $fileName "set __suc -1"
#@    puts $fileName "set __res 0"
#@    puts $fileName "redirect $teeOpt -file $logFilePath {"
#@    puts $fileName "  set __suc \[ catch {"
#@    puts $fileName "    set_host_options -max_cores $maxThreadCount"
#@ 
#@    puts $fileName "    create_fusion_lib $libPath $dbNamesOpt $frameNdmsOpt $dbCreateFlag $frameCreateFlag $isForce"
#@    puts $fileName "  } __res \]"
#@    puts $fileName "  if { \$__suc == 0 && \$__res == 1 } {"
#@    puts $fileName "    set __suc \[ catch {"
#@    if { $removeCellNames != "" } {
#@    puts $fileName "      remove_physical_cells {$removeCellNames}"
#@    }
#@    puts $fileName "      close_fusion_lib -save"
#@    puts $fileName "    } __res \]"
#@    puts $fileName "  }"
#@    puts $fileName "  catch { close_fusion_lib -force }"
#@    puts $fileName "  set __res"
#@    puts $fileName "}"
#@    gen_check_status_procedure $fileName $statusFile 1
#@   
#@    close $fileName
#@ 
#@    lappend ::compile_lib_list $statusFile
#@ }
#@ 
#@ proc gen_compile_flib_from_lef_script { useCdpl index libPath dbNames lefNames framePathes techName scaleFactor postScripts dbCreateFlag frameCreateFlag isForce logFilePath tclFilePath maxThreadCount verbose {minCoverDbs ""} {includeCellNames ""} {restoreProcessScript ""} {setPolicyScript ""} } {
#@    set libPath [file normalize $libPath]
#@    set libName [file tail $libPath]
#@    set statusFile "compile_fusion_lib_${index}_${libName}"
#@ 
#@    set fileName [open $tclFilePath a]
#@    if { $useCdpl } {
#@      gen_cdpl_header_procedure $fileName $restoreProcessScript $setPolicyScript
#@    }
#@ 
#@    if { !$useCdpl && $verbose } {
#@      set teeOpt "-tee"
#@    } else {
#@      set teeOpt ""
#@    }
#@    if { $isForce } {
#@      set isForce "-force"
#@    } else {
#@      set isForce ""
#@    }
#@    if { $dbNames!="" } {
#@      set dbNamesOpt "-dbs $dbNames"
#@    } else {
#@      set dbNamesOpt ""
#@    }
#@    if { $framePathes!="" } {
#@      set frameNdmsOpt "-frames $framePathes"
#@    } else {
#@      set frameNdmsOpt ""
#@    }
#@ 
#@    gen_recreate_frame_proc $fileName
#@    gen_create_frame_from_lef_proc $fileName
#@ 
#@    set logFilePath [file normalize $logFilePath]
#@    puts $fileName "set __suc -1"
#@    puts $fileName "set __res 0"
#@    puts $fileName "redirect $teeOpt -file $logFilePath {"
#@    puts $fileName "  set __saved_include_design_filters \"[get_app_option_value -name physical_lib.include_design_filters]\""
#@    puts $fileName "  set_app_options -name physical_lib.include_design_filters -value $includeCellNames"
#@    puts $fileName "  set __suc \[ catch {"
#@    puts $fileName "    set_host_options -max_cores $maxThreadCount"
#@ 
#@    puts $fileName "    set __lefNames $lefNames"
#@    puts $fileName "    set __framePathes $framePathes"
#@    puts $fileName "    set __postScripts $postScripts"
#@    puts $fileName "    set __index 0"
#@    puts $fileName "    set __frameNum [llength $lefNames]"
#@    puts $fileName "    for {} {\$__index < \$__frameNum} {incr __index} {"
#@    puts $fileName "      set __lefFiles \[lindex \$__lefNames \$__index\]"
#@    puts $fileName "      set __framePath \[lindex \$__framePathes \$__index\]"
#@    puts $fileName "      set __postScript \[lindex \$__postScripts \$__index\]"
#@ 
#@    puts $fileName "      catch {"
#@    puts $fileName "        create_frame_from_lef \$__lefFiles \$__framePath {$techName} {$scaleFactor} {$minCoverDbs} \$__postScript"
#@    puts $fileName "      }"
#@    puts $fileName "      close_physical_lib"
#@    puts $fileName "    }"
#@ 
#@    puts $fileName "    create_fusion_lib $libPath $dbNamesOpt $frameNdmsOpt $dbCreateFlag $frameCreateFlag $isForce"
#@    puts $fileName "  } __res \]"
#@    puts $fileName "  if { \$__suc == 0 && \$__res == 1 } {"
#@    puts $fileName "    set __suc \[ catch {"
#@    puts $fileName "      close_fusion_lib -save"
#@    puts $fileName "    } __res \]"
#@    puts $fileName "  }"
#@    puts $fileName "  catch { close_fusion_lib -force }"
#@    puts $fileName "  set_app_options -name physical_lib.include_design_filters -value \$__saved_include_design_filters"
#@    puts $fileName "  set __res"
#@    puts $fileName "}"
#@    gen_check_status_procedure $fileName $statusFile 1
#@   
#@    close $fileName
#@ 
#@    lappend ::compile_lib_list $statusFile
#@ }
#@ 
#@ proc gen_compile_flib_from_mw_script { useCdpl index libPath dbNames mwLibPathes framePathes dbCreateFlag frameCreateFlag isForce logFilePath tclFilePath logFileDir maxThreadCount allow10NmMw verbose {minCoverDbs ""} {includeCellNames ""} {restoreProcessScript ""} {setPolicyScript ""} } {
#@    set libPath [file normalize $libPath]
#@    set libName [file tail $libPath]
#@    set statusFile "compile_fusion_lib_${index}_${libName}"
#@ 
#@    set fileName [open $tclFilePath a]
#@    if { $useCdpl } {
#@      gen_cdpl_header_procedure $fileName $restoreProcessScript $setPolicyScript
#@    }
#@ 
#@    if { !$useCdpl && $verbose } {
#@      set teeOpt "-tee"
#@    } else {
#@      set teeOpt ""
#@    }
#@    if { $isForce } {
#@      set isForce "-force"
#@    } else {
#@      set isForce ""
#@    }
#@    if { $dbNames!="" } {
#@      set dbNamesOpt "-dbs $dbNames"
#@    } else {
#@      set dbNamesOpt ""
#@    }
#@    if { $framePathes!="" } {
#@      set frameNdmsOpt "-frames $framePathes"
#@    } else {
#@      set frameNdmsOpt ""
#@    }
#@ 
#@    gen_recreate_frame_proc $fileName
#@    gen_generate_frame_from_mw_proc $fileName
#@ 
#@    set logFilePath [file normalize $logFilePath]
#@    puts $fileName "set __suc -1"
#@    puts $fileName "set __res 0"
#@    puts $fileName "redirect $teeOpt -file $logFilePath {"
#@    puts $fileName "  set __saved_include_design_filters \"[get_app_option_value -name physical_lib.include_design_filters]\""
#@    puts $fileName "  set_app_options -name physical_lib.include_design_filters -value $includeCellNames"
#@    puts $fileName "  set __suc \[ catch {"
#@    puts $fileName "    set_host_options -max_cores $maxThreadCount"
#@ 
#@    puts $fileName "    set __mwLibPathes $mwLibPathes"
#@    puts $fileName "    set __framePathes $framePathes"
#@    puts $fileName "    set __logFileDir $logFileDir"
#@    puts $fileName "    set __index 0"
#@    puts $fileName "    set __frameNum [llength $framePathes]"
#@    puts $fileName "    for {} {\$__index < \$__frameNum} {incr __index} {"
#@    puts $fileName "      set __mwLibPath \[lindex \$__mwLibPathes \$__index\]"
#@    puts $fileName "      set __framePath \[lindex \$__framePathes \$__index\]"
#@ 
#@    puts $fileName "      catch {"
#@    puts $fileName "        generate_frame_from_mw_wrapper \$__mwLibPath \$__framePath \$__logFileDir {$minCoverDbs} $allow10NmMw $useCdpl"
#@    puts $fileName "      }"
#@    puts $fileName "      close_physical_lib"
#@    puts $fileName "    }"
#@ 
#@    puts $fileName "    create_fusion_lib $libPath $dbNamesOpt $frameNdmsOpt $dbCreateFlag $frameCreateFlag $isForce"
#@    puts $fileName "  } __res \]"
#@    puts $fileName "  if { \$__suc == 0 && \$__res == 1 } {"
#@    puts $fileName "    set __suc \[ catch {"
#@    puts $fileName "      close_fusion_lib -save"
#@    puts $fileName "    } __res \]"
#@    puts $fileName "  }"
#@    puts $fileName "  catch { close_fusion_lib -force }"
#@    puts $fileName "  set_app_options -name physical_lib.include_design_filters -value \$__saved_include_design_filters"
#@    puts $fileName "  set __res"
#@    puts $fileName "}"
#@    gen_check_status_procedure $fileName $statusFile 1
#@   
#@    close $fileName
#@ 
#@    lappend ::compile_lib_list $statusFile
#@ }
#@ 
#@ proc gen_compile_flib_lef_to_frame_script { useCdpl index lefName framePath techName scaleFactor postScript logFilePath tclFilePath maxThreadCount verbose } {
#@    set frameTailName [file tail $framePath]
#@    set frameTailRootName [file rootname $frameTailName]
#@    set statusFile "lef_to_frame_${index}_${frameTailName}"
#@ 
#@    set fileName [open $tclFilePath a]
#@ 
#@    if { $useCdpl } {
#@      gen_cdpl_header_procedure $fileName {} {}
#@    }
#@ 
#@    if { !$useCdpl && $verbose } {
#@      set teeOpt "-tee"
#@    } else {
#@      set teeOpt ""
#@    }
#@ 
#@    gen_recreate_frame_proc $fileName
#@    gen_create_frame_from_lef_proc $fileName
#@ 
#@    set logFilePath [file normalize $logFilePath]
#@    puts $fileName "set __suc -1"
#@    puts $fileName "set __res 0"
#@    puts $fileName "redirect $teeOpt -file $logFilePath {"
#@    puts $fileName "  set __suc \[ catch {"
#@    puts $fileName "    set_host_options -max_cores $maxThreadCount"
#@    puts $fileName "    create_frame_from_lef $lefName $framePath {$techName} {$scaleFactor} {} {$postScript}"
#@    puts $fileName "  } __res \]"
#@    puts $fileName "  catch { close_physical_lib }"
#@    puts $fileName "  set __res"
#@    puts $fileName "}"
#@    gen_check_status_procedure $fileName $statusFile 1
#@   
#@    close $fileName
#@ 
#@    lappend ::compile_lib_list $statusFile
#@ }
#@ 
#@ # this is for icc shell
#@ proc gen_compile_flib_dump_mw_fram_script { useCdpl index mwLibPath dataPath logFilePath tclFilePath allow10NmMw verbose } {
#@    set mwLibTailName [file tail $mwLibPath]
#@    set mwLibTailRootName [file rootname $mwLibTailName]
#@    set statusFile "dump_mw_fram_${index}_${mwLibTailName}"
#@ 
#@    set fileName [open $tclFilePath a]
#@ 
#@    set logFilePath [file normalize $logFilePath]
#@ 
#@    if { !$useCdpl && $verbose } {
#@      set teeOpt "-tee"
#@    } else {
#@      set teeOpt ""
#@    }
#@    if { $allow10NmMw } {
#@      set internalOpt "-internal"
#@    } else {
#@      set internalOpt ""
#@    }
#@    puts $fileName "set __suc -1"
#@    puts $fileName "set __res 0"
#@    puts $fileName "redirect $teeOpt -file $logFilePath {"
#@    puts $fileName "  set __suc \[ catch {"
#@    puts $fileName "    export_icc2_frame -library $mwLibPath -output_directory $dataPath $internalOpt"
#@    puts $fileName "  } __res \]"
#@    puts $fileName "  set __res"
#@    puts $fileName "}"
#@    gen_check_status_procedure $fileName $statusFile $useCdpl
#@   
#@    close $fileName
#@ 
#@    lappend ::compile_lib_list $statusFile
#@ }
#@ 
#@ # this is for lc shell
#@ proc gen_compile_flib_generate_frame_from_mw_data_script { useCdpl index mwLibPath dataFilePath framePath techName logFilePath tclFilePath verbose } {
#@    set frameTailName [file tail $framePath]
#@    set frameDirName [file dirname $framePath]
#@    set statusFile "generate_frame_from_mw_data_${index}_${frameTailName}"
#@ 
#@    set fileName [open $tclFilePath a]
#@ 
#@    set logFilePath [file normalize $logFilePath]
#@ 
#@    if { !$useCdpl && $verbose } {
#@      set teeOpt "-tee"
#@    } else {
#@      set teeOpt ""
#@    }
#@    puts $fileName "set __suc -1"
#@    puts $fileName "set __res 0"
#@    puts $fileName "redirect $teeOpt -append -file $logFilePath {"
#@    puts $fileName "  set __pwd [pwd]"
#@    puts $fileName "  set __suc \[ catch {"
#@    puts $fileName "    cd $frameDirName"
#@    puts $fileName "    create_physical_lib $frameTailName -technology $techName"
#@    puts $fileName "    import_icc_fram $dataFilePath"
#@    puts $fileName "    write_physical_lib -output $framePath"
#@    puts $fileName "  } __res \]"
#@    puts $fileName "  catch { close_physical_lib }"
#@    puts $fileName "  cd \$__pwd"
#@    puts $fileName "  set __res"
#@    puts $fileName "}"
#@    gen_check_status_procedure $fileName $statusFile 1
#@   
#@    close $fileName
#@ 
#@    lappend ::compile_lib_list $statusFile
#@ }
#@ 
#@ proc gen_compile_flib_generate_frame_from_mw_fram_script { useCdpl index mwLibPath framePath logFilePath tclFilePath logFileDir allow10NmMw verbose } {
#@    set frameTailName [file tail $framePath]
#@    set statusFile "generate_frame_from_mw_fram_${index}_${frameTailName}"
#@ 
#@ 
#@    set fileName [open $tclFilePath a]
#@ 
#@    if { $useCdpl } {
#@      gen_cdpl_header_procedure $fileName {} {}
#@    }
#@ 
#@    set logFilePath [file normalize $logFilePath]
#@ 
#@    if { !$useCdpl && $verbose } {
#@      set teeOpt "-tee"
#@    } else {
#@      set teeOpt ""
#@    }
#@    if { $allow10NmMw } {
#@      set internalOpt "-internal"
#@    } else {
#@      set internalOpt ""
#@    }
#@    if { $useCdpl } {
#@      set useIccOpt "-use_icc"
#@    } else {
#@      set useIccOpt ""
#@    }
#@    puts $fileName "set __suc -1"
#@    puts $fileName "set __res 0"
#@    puts $fileName "redirect $teeOpt -file $logFilePath {"
#@    puts $fileName "  set __suc \[ catch {"
#@    puts $fileName "    generate_frame_from_mw $framePath -mw_lib $mwLibPath -log_file_dir $logFileDir $internalOpt $useIccOpt"
#@    puts $fileName "  } __res \]"
#@    puts $fileName "  set __res"
#@    puts $fileName "}"
#@    gen_check_status_procedure $fileName $statusFile 1
#@   
#@    close $fileName
#@ 
#@    lappend ::compile_lib_list $statusFile
#@ }
#@ 
#@ proc gen_compile_flib_create_dummy_frame_script { framePath techName scaleFactor logFilePath tclFilePath verbose } {
#@    set frameTailName [file tail $framePath]
#@    set frameTailRootName [file rootname $frameTailName]
#@ 
#@    set fileName [open $tclFilePath a]
#@ 
#@    set logFilePath [file normalize $logFilePath]
#@    if { $scaleFactor != "" } {
#@      set scaleFactor "-scale_factor $scaleFactor"
#@    }
#@ 
#@    if { $verbose } {
#@      set teeOpt "-tee"
#@    } else {
#@      set teeOpt ""
#@    }
#@    puts $fileName "set __suc -1"
#@    puts $fileName "set __res 0"
#@    puts $fileName "redirect $teeOpt -file $logFilePath {"
#@    puts $fileName "  set __suc \[ catch {"
#@    puts $fileName "    create_physical_lib $frameTailRootName -technology $techName $scaleFactor"
#@    puts $fileName "    write_physical_lib -output $framePath"
#@    puts $fileName "  } __res \]"
#@    puts $fileName "  catch { close_physical_lib }"
#@    puts $fileName "  set __res"
#@    puts $fileName "}"
#@    puts $fileName "if { \$__suc == 0 && \$__res == 1 } {"
#@    puts $fileName "  return 1"
#@    puts $fileName "} else {"
#@    puts $fileName "  return 0"
#@    puts $fileName "}"
#@   
#@    close $fileName
#@ }
#@ 
#@ proc gen_compile_flib_update_frame_script { useCdpl index frameNdm logFilePath tclFilePath maxThreadCount verbose {minCoverDbs ""} } {
#@    set fileName [open $tclFilePath a]
#@ 
#@    set frameNdm [file normalize $frameNdm]
#@    set libName [file tail $frameNdm]
#@    set statusFile "update_frame_${index}_${libName}"
#@ 
#@    if { $useCdpl } {
#@      gen_cdpl_header_procedure $fileName {} {}
#@    }
#@ 
#@    set logFilePath [file normalize $logFilePath]
#@    if { !$useCdpl && $verbose } {
#@      set teeOpt "-tee"
#@    } else {
#@      set teeOpt ""
#@    }
#@ 
#@    gen_recreate_frame_proc $fileName
#@ 
#@    puts $fileName "set __suc -1"
#@    puts $fileName "set __res 0"
#@    puts $fileName "redirect $teeOpt -file $logFilePath {"
#@    puts $fileName "  set __suc \[ catch {"
#@    puts $fileName "    set_host_options -max_cores $maxThreadCount"
#@ 
#@    puts $fileName "    set __frameNdm \"$frameNdm\""
#@    puts $fileName "    set __minCoverDbs \"$minCoverDbs\""
#@    puts $fileName "    open_physical_lib \$__frameNdm"
#@    puts $fileName "    update_physical_properties -include_pin_attributes secondary_pg -verbose -format db -files \$__minCoverDbs"
#@    puts $fileName "    recreate_frame"
#@    puts $fileName "    write_physical_lib -force -output \$__frameNdm"
#@    puts $fileName "  } __res \]"
#@    puts $fileName "  close_physical_lib"
#@    puts $fileName "  set __res"
#@    puts $fileName "}"
#@    gen_check_status_procedure $fileName $statusFile 1
#@   
#@    close $fileName
#@ 
#@    lappend ::compile_lib_list $statusFile
#@ }
#@ 
#@ proc gen_source_lm_migration_scripts_procedure { index lmTclPath logFileDir maxThreadCount } {
#@    set prefix "source_lm_migration_scripts_"
#@    set prefixI "$prefix$index"
#@    set cwd "${::compile_libs_cwd}"
#@    set wrkDir "${cwd}/${prefixI}"
#@    set tclFileName "$::compile_libs_script_path/${prefixI}"
#@    set fileName [open $tclFileName a]
#@    set logFileName ${prefixI}.log
#@    puts $fileName "if { \$::compile_libs_var_exported != true } {"
#@    puts $fileName "  echo \"var not exported\" "
#@    export_tcl_var $fileName
#@    puts $fileName "  set ::compile_libs_var_exported true"
#@    puts $fileName "}"
#@    puts $fileName "set suc -1"
#@    if { $logFileDir=="" } {
#@      set logFileDir ${cwd}
#@    }
#@    set cmd "redirect -file $logFileDir/$logFileName { set suc \[set_host_options -max_cores $maxThreadCount; report_host_options"
#@    puts $fileName "$cmd; file delete -force $wrkDir; file mkdir $wrkDir; cd $wrkDir; source -echo -verbose $lmTclPath; cd ${cwd}] }"
#@    puts $fileName "if { 1 } {"
#@    puts $fileName "  set sucFlag \[ open $::compile_libs_temp_directory/sucFlags/\[file tail $lmTclPath\] a \]"
#@    puts $fileName "  close \$sucFlag "
#@    puts $fileName "} else {"
#@    puts $fileName "  set failFlag \[ open $::compile_libs_temp_directory/failFlags/\[file tail $lmTclPath\] a \]"
#@    puts $fileName "  close \$failFlag "
#@    puts $fileName "}"
#@   
#@    close $fileName
#@ }
#@ 
#@ proc report_compile_libs { } {
#@   set sucLibs [glob -nocomplain -directory  $::compile_libs_temp_directory/sucFlags * ]
#@   set failLibs [glob -nocomplain -directory  $::compile_libs_temp_directory/failFlags * ]
#@   set failSuclibs "" 
#@   foreach lib $failLibs {
#@     lappend failSuclibs  [file tail $lib]  
#@   }
#@   foreach lib $sucLibs {
#@     lappend failSuclibs [file tail $lib]  
#@   }
#@   set allLibs ""
#@   foreach lib $::compile_lib_list {
#@     lappend allLibs [file tail $lib]  
#@   }
#@   set allLibs [ lsort -unique $allLibs ]
#@   set failSuclibs [ lsort -unique $failSuclibs ]
#@   set index2 0
#@   set fatalLibs ""
#@   foreach libBaseName $allLibs {
#@     #echo $libBaseName, [lindex $failSuclibs $index2]
#@     if { $libBaseName != [lindex $failSuclibs $index2] } {
#@       lappend fatalLibs $libBaseName
#@       continue
#@     } else {
#@       incr index2
#@     }
#@   }
#@   echo "=================================================================="
#@   echo "[llength $sucLibs] libs are compiled successfully, [llength $failLibs] failed, [llength $fatalLibs] fatal."
#@   set failSuclibs "" 
#@   set nFail [llength $failLibs]
#@   if { $nFail > 0} {
#@     echo "The following are the failed list. Please check the log file for details."
#@     foreach lib $failLibs {
#@       echo [file tail $lib]
#@     }
#@   }
#@   set nFatal [llength $fatalLibs]
#@   if { $nFatal > 0} {
#@     echo "The following libs meet unexpected error which cause LC to be fatal. Please contact support from Synopsys."
#@     foreach lib $fatalLibs {
#@       echo $lib
#@     }
#@   }
#@   return [expr $nFail + $nFatal]
#@ }
#@ 
#@ proc report_run_result { work logFileDir } {
#@   set sucLibs [glob -nocomplain -directory  $::compile_libs_temp_directory/sucFlags * ]
#@   set failLibs [glob -nocomplain -directory  $::compile_libs_temp_directory/failFlags * ]
#@   set failSuclibs "" 
#@   foreach lib $failLibs {
#@     lappend failSuclibs  [file tail $lib]  
#@   }
#@   foreach lib $sucLibs {
#@     lappend failSuclibs [file tail $lib]  
#@   }
#@   set allLibs ""
#@   foreach lib $::compile_lib_list {
#@     lappend allLibs [file tail $lib]  
#@   }
#@   set allLibs [ lsort -unique $allLibs ]
#@   set failSuclibs [ lsort -unique $failSuclibs ]
#@   set index2 0
#@   set fatalLibs ""
#@   foreach libBaseName $allLibs {
#@     #echo $libBaseName, [lindex $failSuclibs $index2]
#@     if { $libBaseName != [lindex $failSuclibs $index2] } {
#@       lappend fatalLibs $libBaseName
#@       continue
#@     } else {
#@       incr index2
#@     }
#@   }
#@   echo "=================================================================="
#@   echo "[llength $sucLibs] $work successfully, [llength $failLibs] failed, [llength $fatalLibs] fatal."
#@   set failSuclibs "" 
#@   set nFail [llength $failLibs]
#@   if { $nFail > 0} {
#@     echo "Error: there are failed libs. Please check following log files for detail."
#@     foreach lib $failLibs {
#@       if { $logFileDir != "" } {
#@         echo "${logFileDir}/[file tail $lib].log"
#@       } else {
#@         echo "[file tail $lib].log"
#@       }
#@     }
#@   }
#@   set nFatal [llength $fatalLibs]
#@   if { $nFatal > 0} {
#@     echo "The following libs meet unexpected error which cause LC to be fatal. Please contact support from Synopsys."
#@     foreach lib $fatalLibs {
#@       echo $lib
#@     }
#@   }
#@   return [expr $nFail + $nFatal]
#@ }
#@ 
#@ proc report_source_lm_migration_scripts { debug } {
#@   set sucLibs [glob -nocomplain -directory  $::compile_libs_temp_directory/sucFlags * ]
#@   set sucLibsCnt [llength $sucLibs]
#@   # move generated directories (*.ndm, *.nlib or more?) to ./
#@ #  foreach dir [glob -nocomplain -type d $::compile_libs_cwd/source_lm_migration_scripts_*/*] {
#@ #    set dest "$::compile_libs_cwd/[file tail $dir]"
#@ #    file delete -force $dest
#@ #    file rename -force $dir $dest 
#@ #  }
#@   # and then delete source_lm_migration_scripts_*
#@ #  foreach dir [glob -nocomplain -type d $::compile_libs_cwd/source_lm_migration_scripts_*] {
#@ #    file delete -force $dir
#@ #  }
#@   # delete tmp hidden dir
#@   if { $debug == false } {
#@     set scripts [glob -nocomplain -directory  $::compile_libs_script_path * ]
#@     if { [llength $scripts] == $sucLibsCnt } {
#@       ### add a short sleep before the delete waiting for file handle close
#@       set ::img_create_sleep 0
#@       after 5000 [list set ::img_create_sleep 1]
#@       vwait ::img_create_sleep
#@       file delete -force $::compile_libs_temp_directory
#@     }
#@   }
#@   echo "=================================================================="
#@   echo "$sucLibsCnt scripts are run. Please check the log file for details."
#@ }
#@ 
#@ 
#@ # create the unique folder under tmp
#@ proc set_script_path_var { processDirName } {
#@   set fileName .[pid]
#@   set var [append fileName "_" [clock microseconds]] 
#@   file delete -force [pwd]/$var
#@   file mkdir [pwd]/$var/
#@   file mkdir [pwd]/$var/preCompile
#@   file mkdir [pwd]/$var/$processDirName
#@   file mkdir [pwd]/$var/sucFlags
#@   file mkdir [pwd]/$var/failFlags
#@   file mkdir [pwd]/$var/cdpl
#@   setenv CDPL_LOGDIR "[pwd]/$var/cdpl"
#@   set ::compile_libs_temp_directory "[pwd]/$var"
#@   set ::compile_libs_pre_script_path "[pwd]/$var/preCompile"
#@   set ::compile_libs_script_path  "[pwd]/$var/$processDirName"
#@   set ::compile_libs_cdpl_log_directory "[pwd]/$var/cdpl"
#@   set ::compile_libs_cwd "[pwd]"
#@   set ::compile_lib_list ""
#@ }
#@ 
#@ proc gen_get_lic_scripts { } {
#@   set tclFileName "$::compile_libs_pre_script_path/get_lic"
#@   set chan [open $tclFileName a]
#@   export_tcl_vars $chan
#@   #puts $chan "info hostname"
#@   #puts $chan "date"
#@   #puts $chan "get_license Library-Compiler"
#@   puts $chan "set ::compile_libs_var_exported true"
#@   puts $chan "after 5000"
#@   close $chan
#@ }
#@ 
#@ proc gen_compile_lib_scripts { search_path libNamePattern dbFileDir logFileDir } {
#@   foreach path $search_path {
#@     set path [ file normalize $path]
#@      foreach pattern $libNamePattern {
#@        if { [file exists $pattern] } {
#@          set ::compile_lib_list [concat $::compile_lib_list $pattern ]
#@        } else {
#@          set ::compile_lib_list [concat $::compile_lib_list [ glob -nocomplain -directory $path $pattern] ]
#@        }
#@      }
#@   }
#@   set ::compile_lib_list [lsort -unique $::compile_lib_list]
#@   set i 1
#@   foreach libFileName $::compile_lib_list {
#@     set tclFileName "$::compile_libs_script_path/read_lib_$i"
#@     #echo $tclFileName
#@     set chan [open $tclFileName a]
#@     #echo $libFileName
#@     gen_compile_lib_procedure $chan $libFileName $dbFileDir $logFileDir
#@     close $chan
#@     incr i
#@   }
#@ }
#@ 
#@ proc __rename_commands { cmd_black_list } {
#@   set all_cmds [get_defined_commands]
#@   foreach cmd $all_cmds {
#@     if  { [lsearch $cmd_black_list $cmd] != -1 } {
#@       rename -hidden -force $cmd ____$cmd
#@     }
#@   }
#@ }
#@ 
#@ # 
#@ # STAR P80014807-4612
#@ # FL - reserve relative paths to FL directory - instead of golden db/frames
#@ #
#@ # /site1/data/golden/DB
#@ # /site1/data/golden/frame
#@ # 
#@ # assumption: run under the flib dir 
#@ #   /site1/flib
#@ # should have /site1/flib/registry.dat
#@ # 
#@ # Before:
#@ # 
#@ # /site1/flib/1.db -> /site1/data/golden/DB/1.db
#@ # /site1/flib/2.db -> /site1/data/golden/DB/2.db
#@ # /site1/flib/1.ndm -> /site1/data/golden/frame/1.ndm
#@ # 
#@ # After:  
#@ # 
#@ # /site1/flib/1.db -> ../data/golden/DB/1.db
#@ # /site1/flib/2.db -> ../data/golden/DB/2.db
#@ # /site1/flib/1.ndm -> ../data/golden/frame/1.ndm
#@ #
#@ proc countChar {str mapvar} {
#@   return [expr [string length $str]-[string length [string map $mapvar $str]]]
#@ }
#@ proc findHead {s1 s2} {
#@   set head ""
#@   set ts1 [string trim $s1 /]
#@   set ts2 [string trim $s2 /]
#@   foreach w1 [split $ts1 /] w2 [split $ts2 /] {
#@     append head "/" 
#@     if {$w1 eq $w2} {append head $w1} else break
#@   }
#@   return $head 
#@ }
#@ proc __make_data_path_relative { flibPath } {
#@   set curPath [pwd]
#@   set flibPath [file normalize $flibPath]
#@ 
#@   cd $flibPath
#@   set numSlashCur [countChar $flibPath {/ ""} ]
#@ 
#@   # for each symlink (should linked to full path)
#@   foreach linkName [glob -nocomplain -type l *] { 
#@     # get linked full path $absPath
#@     set absPath [file readlink $linkName]
#@     if {[string index $absPath 0] != "/"} {
#@       # already relative
#@       continue; 
#@     }
#@ 
#@     # not guaranteed if "realpath --relative-to" is available 
#@     # set relPath [sh realpath --relative-to=[pwd] $absPath]
#@     # compare $flibPath with $absPath, remove common head, set $relPath = ".../tail"
#@     set head [findHead $flibPath $absPath]
#@     set tail [string range $absPath [string length $head] end]
#@     set numSlashHead [countChar $head {/ ""}]
#@     set numLevelUp [expr $numSlashCur - $numSlashHead + 1]
#@     set pathPrefix [string repeat "../" $numLevelUp]
#@     set relPath $pathPrefix$tail
#@ 
#@     set __catched [ catch {
#@       # re-link the $linkName to $relPath
#@       echo "Linking $linkName to $relPath"
#@       file delete $linkName
#@       file link $linkName $relPath
#@     } ]
#@     if { $__catched } {
#@       echo "Failed."
#@       cd $curPath
#@       return -code error
#@     } else {
#@       echo "Succeeded."
#@     }
#@   }
#@   echo "Information: Data path made relative to $flibPath"
#@   cd $curPath
#@ }
#@ 
#@ source ${synopsys_root}/auxx/LC2/check_lib_common_lc.tbc
#@ # -- Starting source /usr/cad/synopsys/lc/2022.12-sp6/auxx/LC2/check_lib_common_lc.tbc

#@ ##############################################################################
#@ # Author : Yun Zhang
#@ # History: 2020/6/22 created
#@ # Description: This is the source tcl file of check_lib_common_lc.tbc.
#@ #              The procs are all for run common library compiler under the hood.
#@ ##############################################################################
#@ # TclPro::Compiler::Include
#@ 
#@ if {[catch {package require tbcload 1.6} err] == 1} {
#@     return -code error "[info script]: The TclPro ByteCode Loader is not available or does not support the correct version -- $err"
#@ }
#@ tbcload::bceval {
#@ TclPro ByteCode 2 0 1.7 8.5
#@ 20 0 200 30 0 0 156 0 4 20 20 -1 -1
#@ 200
#@ A2F<!(H&s!/HW<!(3E<!2`8s!F_#pv2/YQ#/HW<!-Qr<!2`8s!I%ul#/2:3w/HW<!0c8=!2`
#@ 8s!K7VNw1Dpiw/HW<!2oJ=!2`8s!MI70%@.mf%/HW<!4&|=!2`8s!Pd3-&6qMH&/HW<!78#>
#@ !2`8s!R!jc&JjJE'/HW<!9D5>!2`8s!U<f`';I+'(/HW<!<VP>!2`8s!WNGB(TQ(w)/HW<!>
#@ bb>!2`8s!ZiC?)Zuw!*/HW<!At(?!/E<!!
#@ 20
#@ @1IOwI1IOwI1IOwI1IOwI1IOw
#@ 20
#@ I%%n#I%%n#I%%n#I%%n#Hq^R#
#@ 30
#@ x
#@ 4
#@ ,CHr@
#@ x
#@ 27
#@ lj|Z?w3F/Du'VgC&>m#H8&Z)F5mNaEt-E-
#@ x
#@ 1
#@ A!
#@ p
#@ 5 0 29 3 0 0 20 0 9 5 5 -1 -1
#@ 29
#@ w0E<!w0E<!w0E<!w0E<!6P1qv3&5pv-E<!!z
#@ 5
#@ )|y9v%!
#@ 5
#@ 'wwi%*!
#@ 3
#@ x
#@ 4
#@ m'cSA
#@ x
#@ 7
#@ %H9KDUvg+
#@ x
#@ 23
#@ hgtdD/BsJDZnmX?#O`aEg9m*E_I-,
#@ 0
#@ 0
#@ 0 0
#@ x
#@ 22
#@ epCkBo0m*EpvnX?3DccE,&MEFO(%
#@ x
#@ 7
#@ /^,8AY@c,
#@ x
#@ 25
#@ lj|Z?w3F/Du'VgCg3MTAk'cOBq,BCF4v
#@ x
#@ 2
#@ a,v
#@ p
#@ 26 0 375 16 2 0 144 1 7 26 38 -1 -1
#@ 375
#@ 32fv!8^w!!.H!!!w3E<!JAe`B#1NW<#3WW!(H&s!>SN?!,Ki<!6h)g%0#>6#@Yw4w1/GpvQk
#@ s<!QSa<!2l+dB<jTZ)v*<<!(H&s!8Qr<!=>YQ#5l+UvVL_w!AqXaB:Xs#)v*<<!:>T=!;eQj
#@ w4u&v!>SGY!8^w!!c?)!!'NA9v3DUNw5Qr<!=>YQ#5l+Uv<b7U-CV%Qb5v!!!kv!!!laykBy
#@ 6fr3v*<<!3Jpiw4S60%6fSs!9YQK%AIuaB+&13wv*<<!Xg_bB4v&*'v*<<!4S60%6fSs!KDe
#@ `BKGBK.v*<<!,`yTv6fSs!TIuaB+&13wv*<<!P1caB+&13wv*<<!wO2,!DI_w!gA*07v*<<!
#@ 4S60%6fSs!R0n<vujZRI#3WW!yLDI/F*W8sREPt!5v!!!F!!!!(E`<!8,,pvFaKL&5v!!!.!
#@ !!!?:WH&ISa<!WSa<!GN2,!-i8v!,,:3wv!!!
#@ 26
#@ =+@n#-.^B)XX%n#I=.n#L@!kwc|9p#Bc!
#@ 38
#@ 4N3<!)^k|vlg)urcv7il5w*!!aBpQ%NORS#g%74wwaKU#:E!
#@ 16
#@ x
#@ 17
#@ w3F/D'gi'FrZ!iCnc%UA/v
#@ x
#@ 7
#@ &OQ<@xe|+
#@ x
#@ 5
#@ ijkIDBv
#@ x
#@ 17
#@ k%PJ:qw!d;&MC0:qkXJ:u!
#@ x
#@ 4
#@ m'cSA
#@ x
#@ 6
#@ 1lo(F^(%
#@ x
#@ 1
#@ P!
#@ x
#@ 9
#@ q3HQBb!cr@4v
#@ x
#@ 9
#@ V:wLD5Q<JDP!
#@ x
#@ 1
#@ R!
#@ i
#@ 0
#@ x
#@ 15
#@ -#l#H8&Z)F5mNaEt-E-
#@ x
#@ 8
#@ %xRQB:p2TA
#@ x
#@ 8
#@ i%97A&jmMC
#@ x
#@ 8
#@ qLK;@0dhTA
#@ x
#@ 0
#@ 
#@ 2
#@ L 0 171 102 317 274 -1
#@ C 0 288 14 -1 -1 300
#@ 0
#@ 0 3
#@ 8
#@ rmBq@NjkSA
#@ 0 0 0
#@ 9
#@ rmBq@q,BCF4v
#@ 1 0 0
#@ 4
#@ %xRQB
#@ 2 0 0
#@ x
#@ 18
#@ #k|Z?w3F/Du'VgCf!Q<@y(%
#@ p
#@ 25 0 255 17 0 0 104 0 3 25 25 -1 -1
#@ 255
#@ w0E<!KN2,!EOhw!#0E<!+BE<!41fg&5v!!!/!!!!w-<<!^Kn<v>Me`BJ>'0.#3WW!0#>6#3#
#@ Ts!TG;I/m&3,!/uJv!#0E<!Ga++'M`yTv8^w!!JGv!!*cvpv5JUNw'qrD!:1fg&5v!!!/!!!
#@ !/oJ=!fKn<v>Me`BLP|f.#3WW!0#>6#82Ts!TG;I/o,3,!1,|v!#0E<!CYCqvxKn<v>Me`BJ
#@ >'0.#3WW!0#>6#:8Ts!TG;I/m&3,!/uJv!#0E<!H=J*'M`yTv8^w!!JGv!!*cvpv:v3-&'qr
#@ D!:1fg&5v!!!/!!!!48#>!_Kn<v'0!!
#@ 25
#@ 9egm#KeHK%KeHK%KeHK%?ur!!K;s!!/!
#@ 25
#@ ^'nK%j@<L%j@<L%nRr-&`sMR#ipMR#/!
#@ 17
#@ x
#@ 17
#@ hgtdD/BsJDZnmX?1lo(F@v
#@ x
#@ 4
#@ 8w`TA
#@ x
#@ 25
#@ lj|Z?w3F/Du'VgCg3MTAk'cOBq,BCF4v
#@ x
#@ 7
#@ &OQ<@xe|+
#@ x
#@ 5
#@ s85)F1v
#@ x
#@ 0
#@ 
#@ x
#@ 4
#@ wm<eD
#@ x
#@ 3
#@ kL2-
#@ x
#@ 23
#@ hgtdD/BsJDZnmX?7,V`F'^m*E_I-,
#@ i
#@ 0
#@ x
#@ 4
#@ MyB,E
#@ x
#@ 27
#@ hgtdD/BsJDZnmX?+sEiC%<0CFa@|mAytf+
#@ x
#@ 27
#@ w3F/Du'VgCjNIQBiOjY?w3F/D.jAn/e.Q,
#@ x
#@ 23
#@ hgtdD/BsJDZnmX?#O`aEg9m*E_I-,
#@ x
#@ 25
#@ lj|Z?w3F/Du'VgCg3MTAk'cOBq,BCF4v
#@ x
#@ 27
#@ hgtdD/BsJDZnmX?rTN+ErfR.Dk^CkBf^;-
#@ x
#@ 20
#@ hgtdD/BsJDZnmX?n:=Y?%xRQB
#@ 0
#@ 0
#@ 0 0
#@ x
#@ 20
#@ 3aMTAr-!eD/BsJDZnmX?4|k)F
#@ p
#@ 24 0 195 12 0 0 96 0 3 24 24 -1 -1
#@ 195
#@ w0E<!-fSs!O,uc/ViA9v,|8X!M`yTv8^w!!B/v!!w-*!!*`vpv'qrD!-A77w.r=6#Omm<v>M
#@ e`BBKMT+#3WW!w0E<!3#Ts!O,uc/ViA9v2o8X!M`yTv8^w!!B/v!!w-*!!-&tl#'qrD!-A77
#@ w0/tl#Omm<v>Me`BBKMT+#3WW!w0E<!5)Ts!O,uc/ViA9v4u8X!M`yTv8^w!!B/v!!w-*!!/
#@ 8UNw'qrD!-A77w2AUNwOmm<v'0!!
#@ 24
#@ /JHK%CeHK%CeHK%CeHK%CeHK%CeHK%
#@ 24
#@ QMbpvZMbpvZMbpvZMbpvZMbpvYMbpv
#@ 12
#@ x
#@ 4
#@ wm<eD
#@ x
#@ 3
#@ kL2-
#@ x
#@ 17
#@ hgtdD/BsJDZnmX?1lo(F@v
#@ i
#@ 0
#@ x
#@ 5
#@ 3aMTA@v
#@ x
#@ 0
#@ 
#@ x
#@ 23
#@ hgtdD/BsJDZnmX?7,V`F'^m*E_I-,
#@ x
#@ 21
#@ w3F/Du'VgCf-DTA@)QDFq,BCF4v
#@ x
#@ 27
#@ hgtdD/BsJDZnmX?+sEiC%<0CFa@|mAytf+
#@ x
#@ 23
#@ hgtdD/BsJDZnmX?#O`aEg9m*E_I-,
#@ x
#@ 27
#@ hgtdD/BsJDZnmX?rTN+ErfR.Dk^CkBf^;-
#@ x
#@ 20
#@ hgtdD/BsJDZnmX?n:=Y?%xRQB
#@ 0
#@ 0
#@ 0 0
#@ x
#@ 8
#@ k^YSAqP(yG
#@ x
#@ 1
#@ ?v
#@ p
#@ 2 0 26 4 0 0 8 0 5 2 2 -1 -1
#@ 26
#@ w0E<!.9`W!0&5Uv8^w!!-E!!!-iA=!z
#@ 2
#@ .H!
#@ 2
#@ :E!
#@ 4
#@ x
#@ 6
#@ gd|;@b:%
#@ x
#@ 4
#@ rwIID
#@ x
#@ 2
#@ >Kv
#@ x
#@ 3
#@ g'i-
#@ 0
#@ 0
#@ 1 2
#@ 1
#@ ?v
#@ 0 0 256
#@ 3
#@ g'i-
#@ 1 0 0
#@ x
#@ 24
#@ #k|Z?w3F/Du'VgCd?<eDtc/bEu,aaE
#@ p
#@ 9 0 92 15 0 0 36 0 6 9 9 -1 -1
#@ 92
#@ )Nr<!I>e`BQ(;E0#3WW!+I*%;v9o7-S^w!!;o!!!w3E<!*TA9v.lvpv1l8X!`(kq+1oes!6G
#@ :3w:_piw<&|=!6)Ks!/HW<!:,f=!Gk60%4DkUv-E<!!
#@ 9
#@ 1GUm#I:*L%4!
#@ 9
#@ a#L>vbpy*'1!
#@ 15
#@ x
#@ 3
#@ _e|+
#@ x
#@ 20
#@ hgtdD/BsJDZnmX?n:=Y?%xRQB
#@ i
#@ 0
#@ x
#@ 6
#@ sT2TAIPw
#@ x
#@ 8
#@ m'cSANjkSA
#@ x
#@ 1
#@ +v
#@ x
#@ 5
#@ n0Hr@7v
#@ x
#@ 12
#@ #graEv_Bq@,0B(F
#@ x
#@ 0
#@ 
#@ x
#@ 4
#@ m'cSA
#@ x
#@ 6
#@ gpbSAPSw
#@ x
#@ 6
#@ AP5cE?Sw
#@ x
#@ 23
#@ hgtdD/BsJDZnmX?7,V`F'^m*E_I-,
#@ x
#@ 1
#@ P!
#@ x
#@ 5
#@ r!2kB>v
#@ 0
#@ 0
#@ 0 1
#@ 8
#@ m'cSANjkSA
#@ 0 0 0
#@ x
#@ 14
#@ 4rBfD1-0CFq&fwGJ%%
#@ x
#@ 10
#@ (KxhCN1-.DQ-v
#@ p
#@ 17 0 213 23 2 1 84 2 10 17 21 -1 -1
#@ 213
#@ w0E<!(H&s!*N&s!+Q&s!,T&s!CY,>!8^w!!2V'!!*i=6#4;tl#=MGY!g@#!!ee6(!H,FN-gE
#@ EfR8SUNw<P>:v8P60%.EW<!--<<!BJ:3w0T`<!Q.taBLP|f.v*<<!f!!!!6^w!!/K!!!12>:
#@ vI,s<!Hv(g7.CI.!4qVH&7P60%DPe`Bbl^l5#3WW!@A#>!T,PU,=;'v!Bb>:vJjJE'5v!!!-
#@ !!!!@=N-&?@e`'4oSs!eFNH&>thc&FO+'(2iSs!G;O8sBA6-&z
#@ 17
#@ C^No#L2#Y!_cpw)>2|X!7!
#@ 21
#@ Pf3<!:'Le#-kv:wIT%m5`NOkw/!
#@ 23
#@ x
#@ 4
#@ q#TCF
#@ x
#@ 6
#@ hIa:@PSw
#@ x
#@ 11
#@ m9.bEi`JT8eIl,
#@ x
#@ 1
#@ R!
#@ x
#@ 22
#@ q3HQBl#sJD8o(`FnlrJDu_PcEX%%
#@ x
#@ 21
#@ q3HQBkoW/DmgY8AnT_5BgKxhC1v
#@ x
#@ 18
#@ hgtdD!CIIDkcreDb^CkBHSw
#@ x
#@ 4
#@ wm<eD
#@ x
#@ 4
#@ 4|k)F
#@ x
#@ 3
#@ j#L%
#@ x
#@ 2
#@ FVw
#@ x
#@ 5
#@ sB-<@Ev
#@ x
#@ 6
#@ 1lo(F^(%
#@ x
#@ 21
#@ 6dV<+:mui@26nlBPPW(46dV<+A!
#@ x
#@ 6
#@ !xMTAFVw
#@ i
#@ 0
#@ x
#@ 0
#@ 
#@ x
#@ 4
#@ DP)*F
#@ x
#@ 12
#@ h-ur@E5>F+91VE+
#@ x
#@ 25
#@ ruwlB/wJ9>gd|;@>AufA'%U;@(y(S.A!
#@ x
#@ 8
#@ k^YSAqP(yG
#@ x
#@ 4
#@ wg;3I
#@ x
#@ 5
#@ P!i<+Iv
#@ 2
#@ L 0 60 144 210 50 -1
#@ C 1 105 20 -1 -1 123
#@ 1
#@ F
#@ 1 2 3
#@ 1
#@ 4
#@ 1 7
#@ 8
#@ m'cSANjkSA
#@ 0 0 256
#@ 12
#@ 'ZPDFd%+:@EAl)F
#@ 1 0 0
#@ 0
#@ 
#@ 2 0 512
#@ 0
#@ 
#@ 3 0 512
#@ 3
#@ kL2-
#@ 4 0 0
#@ 6
#@ 7,V`FW+%
#@ 5 0 0
#@ 4
#@ .0B,E
#@ 6 0 0
#@ x
#@ 21
#@ ^_`p@hp^LCcXKV@`jbSAp#K^F<v
#@ p
#@ 3 0 36 10 0 0 12 0 6 3 3 -1 -1
#@ 36
#@ /rS=!6U(+((H&s!,`yTv5Qr<!<)Ks!Qsm<v.TW<!19*!!
#@ 3
#@ @nG#
#@ 3
#@ VoE!
#@ 10
#@ x
#@ 27
#@ hgtdD/BsJDZnmX?rTN+ErfR.Dk^CkBf^;-
#@ x
#@ 5
#@ s85)F1v
#@ x
#@ 4
#@ m'cSA
#@ x
#@ 6
#@ gpbSAPSw
#@ x
#@ 6
#@ AP5cE?Sw
#@ x
#@ 23
#@ hgtdD/BsJDZnmX?7,V`F'^m*E_I-,
#@ x
#@ 1
#@ P!
#@ x
#@ 20
#@ hgtdD/BsJDZnmX?n:=Y?%xRQB
#@ x
#@ 0
#@ 
#@ x
#@ 20
#@ 3aMTAr-!eD/BsJDZnmX?4|k)F
#@ 0
#@ 0
#@ 0 0
#@ x
#@ 23
#@ ,v(Z?w3F/Du'VgCoo3mBm+BRAyOl,
#@ x
#@ 8
#@ o4jY?m'cSA
#@ p
#@ 30 0 407 32 2 0 144 1 8 30 34 -1 -1
#@ 407
#@ w0E<!1#T=!/r=pv2G^3w-u4Uv6/Ypv9u&s!5v!!!Q!!!!7kZjwgfvdB>'6<*v*<<!,#tl#9i
#@ A=!Ebpiw8S60%=MGY!VyQK%8^w!!.H!!!2ylf%LGe`B.A-0%v*<<!G1);v8^w!!x')!!EL_w
#@ !T>puB<jTZ)v*<<!!oxR5e:NH&<;YUvPpm<vGhe`B^HGT4v*<<!H^/*'L!f`'GR+'(>bq9-X
#@ ^w!!5|!!!;RFB(Gk#t!COAI&;N2,!+|&v!d&.36VyQK%8^w!!IDv!!5vic&JjJE'J+ZUvHtP
#@ pvTIuaB+&13wv*<<!4Ta<!FN2,!aMg'!,,:3wg6#+15v!!!O!!!!pDhQ5vE3,!.oAv!#0E<!
#@ T2Bs!5v!!!+!!!!9S2U#BhYUvOmm<v4fW<!INE<!HNW<!2E9!sSWXA!FN2,!O6n%!hG307v*
#@ <<!KkB=!9_lf%,eN48;I%!!:n^qvbs7e/mQur*VyQK%8^w!!:l!!!+rXQ#Hv87wLt|X!Omm<
#@ v0K!!
#@ 30
#@ =Xv+'`Q,N%Yp`1%PLdjwY*Th%Wa<kwMhPUvQN!
#@ 34
#@ 6@&a0l*sL%!w!!!i.Wp4WF.4wMuIR5mhtpv#-|rv@3!
#@ 32
#@ x
#@ 4
#@ *dmID
#@ x
#@ 1
#@ Hv
#@ x
#@ 23
#@ hgtdD/BsJDZnmX?#O`aEg9m*E_I-,
#@ x
#@ 20
#@ JaGQB*kbD+nEi'FrZ!iCV%BE+
#@ x
#@ 27
#@ lj|Z?w3F/Du'VgC&>m#H8&Z)F5mNaEt-E-
#@ x
#@ 4
#@ J2*D+
#@ x
#@ 12
#@ vAE-0;oU6036viC
#@ x
#@ 1
#@ >v
#@ x
#@ 27
#@ hgtdD/BsJDZnmX?rTN+ErfR.Dk^CkBf^;-
#@ x
#@ 23
#@ hgtdD/BsJDZnmX?7,V`F'^m*E_I-,
#@ x
#@ 1
#@ P!
#@ x
#@ 20
#@ hgtdD/BsJDZnmX?n:=Y?%xRQB
#@ x
#@ 14
#@ ;oW/D!e'Z?64BbCMYw
#@ x
#@ 1
#@ Cv
#@ x
#@ 0
#@ 
#@ i
#@ 0
#@ x
#@ 4
#@ 8w`TA
#@ x
#@ 4
#@ DP)*F
#@ x
#@ 6
#@ :<ylBLYw
#@ x
#@ 5
#@ wRH<@8v
#@ x
#@ 7
#@ 9WmIDeI-,
#@ x
#@ 1
#@ X!
#@ x
#@ 7
#@ =P6X5R^`w
#@ x
#@ 1
#@ B!
#@ x
#@ 1
#@ A!
#@ x
#@ 2
#@ 2fv
#@ x
#@ 34
#@ Yl<eD,wBCFMk8c3Q@=nA&!=JD'WrSA;cN<@ktWU@HSw
#@ x
#@ 5
#@ s85)F1v
#@ x
#@ 4
#@ +u(*F
#@ x
#@ 4
#@ u3uSA
#@ x
#@ 5
#@ )lP)F1v
#@ x
#@ 0
#@ 
#@ 2
#@ L 0 119 195 331 315 -1
#@ C 0 348 12 -1 -1 358
#@ 0
#@ 1 7
#@ 8
#@ o4jY?m'cSA
#@ 0 0 256
#@ 4
#@ g3IID
#@ 1 0 0
#@ 3
#@ d4w,
#@ 2 0 0
#@ 4
#@ lWNeD
#@ 3 0 0
#@ 9
#@ ,uk)Fdd;JD1v
#@ 4 0 0
#@ 4
#@ u3uSA
#@ 5 0 0
#@ 5
#@ bT/bE>v
#@ 6 0 0
#@ x
#@ 23
#@ w3F/Du'VgCZCbOB_.aY?!aiaEnTr-
#@ x
#@ 11
#@ 0Q%hCgKxhC,tEw
#@ p
#@ 10 0 95 14 0 0 40 0 5 10 10 -1 -1
#@ 95
#@ /rS=!1Gwjw'E&s!H=rH&9N2,!4>##!#0E<!1NE<!@4`H&-fvpv5|8X!6Sp3w25bpv/o=6#7)
#@ tl#2Q/X!.EW<!5TN<!7`8s!9;|X!-BW<!>&#pv4P60%(w!!
#@ 10
#@ GFIOwG17n#/6!
#@ 10
#@ Vv)7#Gh17#,-!
#@ 14
#@ x
#@ 23
#@ hgtdD/BsJDZnmX?7,V`F'^m*E_I-,
#@ x
#@ 1
#@ P!
#@ x
#@ 20
#@ hgtdD/BsJDZnmX?n:=Y?%xRQB
#@ x
#@ 27
#@ hgtdD/BsJDZnmX?+sEiC%<0CFa@|mAytf+
#@ x
#@ 4
#@ *dmID
#@ x
#@ 1
#@ -v
#@ x
#@ 14
#@ 4rBfD1-0CFq&fwGJ%%
#@ x
#@ 4
#@ DP)*F
#@ x
#@ 41
#@ =P6X5r*r<+fF'Z?w3F/Du'VgCZCbOB_.aY?c_dX?,CHr@(okcE1v
#@ x
#@ 7
#@ A;lcE_iGw
#@ x
#@ 7
#@ =P6X5R^`w
#@ x
#@ 5
#@ )lP)F1v
#@ x
#@ 23
#@ ,v(Z?w3F/Du'VgCoo3mBm+BRAyOl,
#@ x
#@ 21
#@ ^_`p@hp^LCcXKV@`jbSAp#K^F<v
#@ 0
#@ 0
#@ 1 3
#@ 9
#@ o4jY?m'cSAQ!
#@ 0 0 256
#@ 8
#@ o4jY?m'cSA
#@ 1 0 0
#@ 4
#@ g3IID
#@ 2 0 0
#@ x
#@ 15
#@ rpwhC;Z2b3<?<+EfqT+
#@ 0
#@ 0
#@ }
#@ # -- End source /usr/cad/synopsys/lc/2022.12-sp6/auxx/LC2/check_lib_common_lc.tbc

#@ # -- End source /usr/cad/synopsys/lc/2022.12-sp6/admin/setup//.synopsys_lc.setup

source -echo -verbose /tmp/_pt1r009RXo
#@ # -- Starting source /tmp/_pt1r009RXo

#@ echo "ptxr"
#@ set search_path  { .  }
#@ set synthetic_library {}
#@ set symbol_library {}
#@ set target_library {}
#@ set generic_symbol_library ""
#@ set hdlin_internal_name_prefix "NN"
#@ set hdlin_auto_netlist_reader "false"
#@ echo "ptxr"
#@ read_lib /home/B11215045/latch/latch/sky130hd_tt.lib.gz
#@ set all_libdes [get_libs *]
#@ if { [sizeof_collection $all_libdes] == 0 } {
#@   exit
#@ }
#@ set loaded {}
#@ foreach_in_collection libdes $all_libdes {
#@   set a_ld [get_object_name $libdes]
#@   lappend loaded $a_ld
#@ }
#@ write_lib -format db -output /tmp/_pt1rj9FJsm/1.db $a_ld
#@ remove_design -all > /dev/null
#@ exit
